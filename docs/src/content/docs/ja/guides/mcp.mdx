---
title: MCP 連携
description: Learn how to utilize MCP servers as tools
---

import { Code } from '@astrojs/starlight/components';
import hostedAgentExample from '../../../../../../examples/docs/mcp/hostedAgent.ts?raw';
import hostedExample from '../../../../../../examples/docs/mcp/hosted.ts?raw';
import hostedStreamExample from '../../../../../../examples/docs/mcp/hostedStream.ts?raw';
import hostedHITLExample from '../../../../../../examples/docs/mcp/hostedHITL.ts?raw';
import hostedConnectorExample from '../../../../../../examples/docs/mcp/hostedConnector.ts?raw';
import streamableHttpExample from '../../../../../../examples/docs/mcp/streamableHttp.ts?raw';
import stdioExample from '../../../../../../examples/docs/mcp/stdio.ts?raw';
import toolFilterExample from '../../../../../../examples/docs/mcp/tool-filter.ts?raw';
import mcpServersExample from '../../../../../../examples/docs/mcp/mcpServers.ts?raw';

[**Model Context Protocol (MCP)**](https://modelcontextprotocol.io) は、アプリケーションが LLM にツールとコンテキストを提供する方法を標準化するオープンなプロトコルです。MCP のドキュメントより:

> MCP は、アプリケーションが LLM にコンテキストを提供する方法を標準化するオープンなプロトコルです。MCP は AI アプリケーション向けの USB-C ポートのようなものだと考えてください。USB-C がさまざまな周辺機器やアクセサリにデバイスを接続するための標準化された方法を提供するのと同様に、MCP は AI モデルを異なるデータソースやツールに接続するための標準化された方法を提供します。

この SDK がサポートする MCP サーバーは 3 種類あります:

1. **リモート MCP サーバーツール** – [OpenAI Responses API](https://platform.openai.com/docs/guides/tools-remote-mcp) がツールとして使用するリモート MCP サーバー
2. **Streamable HTTP MCP サーバー** – [Streamable HTTP transport](https://modelcontextprotocol.io/docs/concepts/transports#streamable-http) を実装するローカルまたはリモートのサーバー
3. **Stdio MCP サーバー** – 標準入出力経由でアクセスするサーバー（最もシンプルな選択肢）

> 注: この SDK には、レガシーな Server‑Sent Events トランスポート向けの `MCPServerSSE` も含まれますが、SSE は MCP プロジェクトで非推奨になっています。新規統合では Streamable HTTP または stdio を推奨します。

ユースケースに応じてサーバータイプを選択してください:

| 必要なこと                                                                           | 推奨オプション          |
| ------------------------------------------------------------------------------------ | ----------------------- |
| 公開アクセス可能なリモートサーバーを、デフォルトの OpenAI responses モデルで呼び出す | **1. Hosted MCP tools** |
| 公開アクセス可能なリモートサーバーを使いつつ、ツール呼び出しはローカルで発火させる   | **2. Streamable HTTP**  |
| ローカルで稼働する Streamable HTTP サーバーを使う                                    | **2. Streamable HTTP**  |
| 非 OpenAI-Responses モデルで任意の Streamable HTTP サーバーを使う                    | **2. Streamable HTTP**  |
| 標準 I/O プロトコルのみをサポートするローカル MCP サーバーを使う                     | **3. Stdio**            |

## 1. リモート MCP サーバーツール

組み込みツール（Hosted）は、往復処理全体をモデル側に委ねます。コードが MCP サーバーを呼び出す代わりに、OpenAI Responses API がリモートツールエンドポイントを呼び出し、結果をモデルにストリーミングで返します。

以下は、組み込みツール（Hosted）を使う最もシンプルな例です。`hostedMcpTool` ユーティリティ関数にリモート MCP サーバーのラベルと URL を渡せます。これは、リモート MCP サーバーツールを作成する際に便利です。

<Code lang="typescript" code={hostedAgentExample} title="hostedAgent.ts" />

次に、`run` 関数（または独自にカスタマイズした `Runner` インスタンスの `run` メソッド）で Agent を実行できます:

<Code
  lang="typescript"
  code={hostedExample}
  title="Run with hosted MCP tools"
/>

増分 MCP 結果をストリーミングするには、`Agent` 実行時に `stream: true` を渡します:

<Code
  lang="typescript"
  code={hostedStreamExample}
  title="Run with hosted MCP tools (streaming)"
/>

### 任意の承認フロー

機密性の高い操作では、個々のツール呼び出しに人間の承認を必須にできます。`requireApproval: 'always'` か、ツール名を `'never'` / `'always'` にマッピングする詳細なオブジェクトを渡してください。

ツール呼び出しが安全かどうかをプログラムで判定できる場合は、[`onApproval` コールバック](https://github.com/openai/openai-agents-js/blob/main/examples/mcp/hosted-mcp-on-approval.ts)を使って承認または拒否できます。人間の承認が必要な場合は、ローカル関数ツールと同様に `interruptions` を使う同じ [人間の介入（HITL）アプローチ](/openai-agents-js/ja/guides/human-in-the-loop/) を利用できます。

<Code
  lang="typescript"
  code={hostedHITLExample}
  title="Human in the loop with hosted MCP tools"
/>

### リモート MCP オプションリファレンス

`hostedMcpTool(...)` は、MCP サーバー URL とコネクタ対応サーバーの両方をサポートします:

| オプション        | 型                              | 注記                                                                                                      |
| ----------------- | ------------------------------- | --------------------------------------------------------------------------------------------------------- |
| `serverLabel`     | `string`                        | 必須。イベントとトレース内でリモート MCP サーバーを識別するラベル                                         |
| `serverUrl`       | `string`                        | リモート MCP サーバー URL（通常のリモート MCP サーバーで使用）                                            |
| `connectorId`     | `string`                        | OpenAI connector id（コネクタ対応の Hosted サーバーでは `serverUrl` の代わりに使用）                      |
| `authorization`   | `string`                        | 任意。Hosted MCP バックエンドに送信する認可トークン                                                       |
| `headers`         | `Record<string, string>`        | 任意の追加リクエストヘッダー                                                                              |
| `allowedTools`    | `string[] \| object`            | モデルに公開するツール名の Allowlist。`string[]` または `{ toolNames?: string[] }` を渡します             |
| `requireApproval` | `'never' \| 'always' \| object` | Hosted MCP ツール呼び出しの承認ポリシー。ツールごとの上書きにはオブジェクト形式を使用。既定値は `'never'` |
| `onApproval`      | Approval callback               | `requireApproval` で承認処理が必要な場合に使う、任意のプログラム的な承認 / 拒否コールバック               |

`requireApproval` のオブジェクト形式:

```ts
{
  always?: { toolNames: string[] };
  never?: { toolNames: string[] };
}
```

`onApproval` のシグネチャ:

```ts
async function onApproval(
  context,
  item,
): Promise<{
  approve: boolean;
  reason?: string;
}> {}
```

### コネクタ対応 Hosted サーバー

Hosted MCP は OpenAI connectors もサポートします。`serverUrl` の代わりに、コネクタの `connectorId` と `authorization` トークンを渡します。すると Responses API が認証を処理し、Hosted MCP インターフェース経由でコネクタのツールを公開します。

<Code
  lang="typescript"
  code={hostedConnectorExample}
  title="Connector-backed hosted MCP tool"
/>

この例では、`GOOGLE_CALENDAR_AUTHORIZATION` 環境変数に Google OAuth Playground で取得した OAuth トークンが入り、これによってコネクタ対応サーバーが Calendar API を呼び出せるようになります。ストリーミングも示す実行可能サンプルは [`examples/connectors`](https://github.com/openai/openai-agents-js/tree/main/examples/connectors) を参照してください。

完全動作するサンプル（Hosted tools / Streamable HTTP / stdio + Streaming、HITL、onApproval）は、GitHub リポジトリの [examples/mcp](https://github.com/openai/openai-agents-js/tree/main/examples/mcp) にあります。

## 2. Streamable HTTP MCP サーバー

Agent が Streamable HTTP MCP サーバー（ローカルまたはリモート）と直接やり取りする場合は、`url`、`name`、および任意設定を指定して `MCPServerStreamableHttp` をインスタンス化します:

<Code
  lang="typescript"
  code={streamableHttpExample}
  title="Run with Streamable HTTP MCP servers"
/>

コンストラクターオプション:

| オプション                    | 型                                             | 注記                                                  |
| ----------------------------- | ---------------------------------------------- | ----------------------------------------------------- |
| `url`                         | `string`                                       | Streamable HTTP サーバー URL                          |
| `name`                        | `string`                                       | サーバーの任意ラベル                                  |
| `cacheToolsList`              | `boolean`                                      | レイテンシ削減のためにツール一覧をキャッシュ          |
| `clientSessionTimeoutSeconds` | `number`                                       | MCP クライアントセッションのタイムアウト              |
| `toolFilter`                  | `MCPToolFilterCallable \| MCPToolFilterStatic` | 利用可能ツールをフィルタリング                        |
| `toolMetaResolver`            | `MCPToolMetaResolver`                          | 呼び出しごとの MCP `_meta` リクエストフィールドを注入 |
| `errorFunction`               | `MCPToolErrorFunction \| null`                 | MCP 呼び出し失敗をモデル可視のテキストにマッピング    |
| `timeout`                     | `number`                                       | リクエストごとのタイムアウト（ミリ秒）                |
| `logger`                      | `Logger`                                       | カスタムロガー                                        |
| `authProvider`                | `OAuthClientProvider`                          | MCP TypeScript SDK の OAuth プロバイダー              |
| `requestInit`                 | `RequestInit`                                  | リクエスト用の Fetch 初期化オプション                 |
| `fetch`                       | `FetchLike`                                    | カスタム fetch 実装                                   |
| `reconnectionOptions`         | `StreamableHTTPReconnectionOptions`            | 再接続のチューニングオプション                        |
| `sessionId`                   | `string`                                       | MCP 接続用の明示的なセッション id                     |

このコンストラクターは、`authProvider`、`requestInit`、`fetch`、`reconnectionOptions`、`sessionId` などの追加の MCP TypeScript‑SDK オプションも受け取れます。詳細は [MCP TypeScript SDK repository](https://github.com/modelcontextprotocol/typescript-sdk) とそのドキュメントを参照してください。

## 3. Stdio MCP サーバー

標準 I/O のみを公開するサーバーでは、`fullCommand` を指定して `MCPServerStdio` をインスタンス化します:

<Code
  lang="typescript"
  code={stdioExample}
  title="Run with Stdio MCP servers"
/>

コンストラクターオプション:

| オプション                    | 型                                             | 注記                                                  |
| ----------------------------- | ---------------------------------------------- | ----------------------------------------------------- |
| `command` / `args`            | `string` / `string[]`                          | stdio サーバー用のコマンド + 引数                     |
| `fullCommand`                 | `string`                                       | `command` + `args` の代替となる完全コマンド文字列     |
| `env`                         | `Record<string, string>`                       | サーバープロセスの環境変数                            |
| `cwd`                         | `string`                                       | サーバープロセスの作業ディレクトリ                    |
| `cacheToolsList`              | `boolean`                                      | レイテンシ削減のためにツール一覧をキャッシュ          |
| `clientSessionTimeoutSeconds` | `number`                                       | MCP クライアントセッションのタイムアウト              |
| `name`                        | `string`                                       | サーバーの任意ラベル                                  |
| `encoding`                    | `string`                                       | stdio ストリームのエンコーディング                    |
| `encodingErrorHandler`        | `'strict' \| 'ignore' \| 'replace'`            | エンコーディングエラー時の戦略                        |
| `toolFilter`                  | `MCPToolFilterCallable \| MCPToolFilterStatic` | 利用可能ツールをフィルタリング                        |
| `toolMetaResolver`            | `MCPToolMetaResolver`                          | 呼び出しごとの MCP `_meta` リクエストフィールドを注入 |
| `errorFunction`               | `MCPToolErrorFunction \| null`                 | MCP 呼び出し失敗をモデル可視のテキストにマッピング    |
| `timeout`                     | `number`                                       | リクエストごとのタイムアウト（ミリ秒）                |
| `logger`                      | `Logger`                                       | カスタムロガー                                        |

## MCP サーバーライフサイクル管理

複数の MCP サーバーを扱う場合、`connectMcpServers` を使ってまとめて接続し、失敗を追跡し、1 か所でクローズできます。
このヘルパーは `active`、`failed`、`errors` コレクションを持つ `MCPServers` インスタンスを返すため、健全なサーバーだけをエージェントに渡せます。

<Code
  lang="typescript"
  code={mcpServersExample}
  title="Manage multiple MCP servers"
/>

ユースケース:

- **複数サーバーを同時利用**: すべてを並列に接続し、エージェントには `mcpServers.active` を使う
- **部分的失敗の処理**: `failed` + `errors` を確認し、続行するか再試行するかを判断
- **失敗サーバーの再試行**: `mcpServers.reconnect()` を呼び出す（既定では失敗サーバーのみ再試行）

厳密な「すべて成功かすべて失敗か」の接続や異なるタイムアウトが必要な場合は、`connectMcpServers(servers, options)` を使い、環境に合わせてオプションを調整してください。

`connectMcpServers` のオプション:

| オプション           | 型               | 既定値  | 注記                                                   |
| -------------------- | ---------------- | ------- | ------------------------------------------------------ |
| `connectTimeoutMs`   | `number \| null` | `10000` | 各サーバー `connect()` のタイムアウト。無効化は `null` |
| `closeTimeoutMs`     | `number \| null` | `10000` | 各サーバー `close()` のタイムアウト。無効化は `null`   |
| `dropFailed`         | `boolean`        | `true`  | 失敗したサーバーを `active` から除外                   |
| `strict`             | `boolean`        | `false` | いずれかのサーバー接続が失敗したら例外を投げる         |
| `suppressAbortError` | `boolean`        | `true`  | failed サーバーを追跡しつつ、abort 類似エラーを無視    |
| `connectInParallel`  | `boolean`        | `false` | 順次ではなく全サーバーを同時接続                       |

`mcpServers.reconnect(options)` がサポートするオプション:

| オプション   | 型        | 既定値 | 注記                                                                |
| ------------ | --------- | ------ | ------------------------------------------------------------------- |
| `failedOnly` | `boolean` | `true` | 失敗サーバーのみ再試行（`true`）または全サーバーを再接続（`false`） |

### 非同期破棄（任意）

ランタイムが `Symbol.asyncDispose` をサポートしている場合、`MCPServers` は `await using` パターンもサポートします。
TypeScript では、`tsconfig.json` で `esnext.disposable` を有効化してください:

```json
{
  "compilerOptions": {
    "lib": ["ES2018", "DOM", "esnext.disposable"]
  }
}
```

次のように記述できます:

```ts
await using mcpServers = await connectMcpServers(servers);
```

## その他の注意点

**Streamable HTTP** と **Stdio** サーバーでは、`Agent` 実行のたびに利用可能ツールを検出するため `list_tools()` を呼ぶことがあります。この往復はレイテンシを増やす可能性があり、特にリモートサーバーで顕著です。そのため、`MCPServerStdio` または `MCPServerStreamableHttp` に `cacheToolsList: true` を渡すと、結果をメモリにキャッシュできます。

ツール一覧が変わらないと確信できる場合にのみ有効化してください。後でキャッシュを無効化するには、サーバーインスタンスで `invalidateToolsCache()` を呼びます。
`getAllMcpTools(...)` による共有 MCP ツールキャッシュを使用している場合は、`invalidateServerToolsCache(serverName)` でサーバー名単位の無効化も可能です。

高度なケースでは、`getAllMcpTools({ generateMCPToolCacheKey })` によりキャッシュ分割をカスタマイズできます（例: サーバー + エージェント + 実行コンテキスト単位）。

### ツールフィルタリング

`createMCPToolStaticFilter` による静的フィルター、またはカスタム関数を渡すことで、各サーバーから公開するツールを制限できます。以下は両方の方法を組み合わせた例です:

<Code lang="typescript" code={toolFilterExample} title="Tool filtering" />

## 関連資料

- [Model Context Protocol](https://modelcontextprotocol.io/) – 公式仕様
- [examples/mcp](https://github.com/openai/openai-agents-js/tree/main/examples/mcp) – 上で参照した実行可能な
  デモ
