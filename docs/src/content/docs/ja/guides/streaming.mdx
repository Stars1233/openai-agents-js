---
title: ストリーミング
description: Stream agent output in real time using the Runner
---

import { Code } from '@astrojs/starlight/components';
import basicStreamingExample from '../../../../../../examples/docs/streaming/basicStreaming.ts?raw';
import nodeTextStreamExample from '../../../../../../examples/docs/streaming/nodeTextStream.ts?raw';
import handleAllEventsExample from '../../../../../../examples/docs/streaming/handleAllEvents.ts?raw';
import streamedHITLExample from '../../../../../../examples/docs/streaming/streamedHITL.ts?raw';

Agents SDK は、モデルおよびその他の実行ステップからの出力を段階的に配信できます。ストリーミングにより UI を応答性良く保ち、エージェントの最終的な実行結果をすべて待たずに ユーザー を更新できます。

## ストリーミングの有効化

`Runner.run()` に `{ stream: true }` オプションを渡すと、完全な結果ではなくストリーミングオブジェクトを取得します:

<Code
  lang="typescript"
  code={basicStreamingExample}
  title="Enabling streaming"
/>

ストリーミングが有効な場合、返される `stream` は `AsyncIterable` インターフェースを実装します。各イベントは、実行内で何が起きたかを示すオブジェクトです。ストリームは 3 種類のイベントタイプのいずれかを生成し、エージェントの実行の異なる部分を記述します。多くのアプリケーションはモデルのテキストのみを必要とするため、ストリームはそのためのヘルパーを提供します。

### テキスト出力の取得

`stream.toTextStream()` を呼び出すと、生成されたテキストのストリームを取得できます。`compatibleWithNodeStreams` が `true` の場合、戻り値は通常の Node.js の `Readable` です。`process.stdout` などへ直接パイプできます。

<Code
  lang="typescript"
  code={nodeTextStreamExample}
  title="Logging out the text as it arrives"
  meta={`{13-17}`}
/>

`stream.completed` の Promise は、実行および保留中のすべてのコールバックが完了すると解決されます。出力がもうないことを確実にするには、必ず await してください。

### すべてのイベントの監視

`for await` ループを使用して、到着した各イベントを検査できます。低レベルのモデルイベント、エージェントの切り替え、SDK 固有の実行情報などが役立ちます:

<Code
  lang="typescript"
  code={handleAllEventsExample}
  title="Listening to all events"
/>

ストリーミングのプレーンテキストと 元 のイベントストリームの両方を出力する完全なスクリプトについては、[the streamed example](https://github.com/openai/openai-agents-js/tree/main/examples/agent-patterns/streamed.ts) を参照してください。

### Responses WebSocket トランスポート（任意）

このページのストリーミング API は、OpenAI Responses WebSocket トランスポートでも動作します。

`setOpenAIResponsesTransport('websocket')` でグローバルに有効化するか、`useResponsesWebSocket: true` を指定した独自の `OpenAIProvider` を使用します。

WebSocket でストリーミングするだけなら、`withResponsesWebSocketSession(...)` やカスタムの `OpenAIProvider` は不要です。実行間での再接続が許容できるなら、トランスポートを有効化した後でも `run()` / `Runner.run(..., { stream: true })` はそのまま動作します。

接続の再利用やより明示的なプロバイダーのライフサイクル管理が必要な場合は、`withResponsesWebSocketSession(...)` またはカスタムの `OpenAIProvider` / `Runner` を使用してください。

プロバイダーを自分で構築した場合は、シャットダウン時に `await provider.close()` を呼び出すことを忘れないでください。WebSocket バックエンドのモデルラッパーはデフォルトで再利用のためキャッシュされ、プロバイダーを閉じるとそれらの接続が解放されます。`withResponsesWebSocketSession(...)` は同様の再利用を提供しつつ、クリーンアップを単一のコールバックに自動的にスコープします。

ストリーミング、ツール呼び出し、承認、`previousResponseId` を含む完全な code examples については、[`examples/basic/stream-ws.ts`](https://github.com/openai/openai-agents-js/tree/main/examples/basic/stream-ws.ts) を参照してください。

## イベントタイプ

ストリームは 3 種類の異なるイベントタイプを生成します:

### raw_model_stream_event

```ts
type RunRawModelStreamEvent = {
  type: 'raw_model_stream_event';
  data: ResponseStreamEvent;
};
```

例:

```json
{
  "type": "raw_model_stream_event",
  "data": {
    "type": "output_text_delta",
    "delta": "Hello"
  }
}
```

### run_item_stream_event

```ts
type RunItemStreamEvent = {
  type: 'run_item_stream_event';
  name: RunItemStreamEventName;
  item: RunItem;
};
```

`name` は、生成されたアイテムの種類を識別します:

| `name`                    | 意味                                                 |
| ------------------------- | ---------------------------------------------------- |
| `message_output_created`  | メッセージ出力アイテムが作成された                   |
| `handoff_requested`       | モデルがハンドオフを要求した                         |
| `handoff_occurred`        | ランタイムが別のエージェントへのハンドオフを完了した |
| `tool_called`             | ツール呼び出しアイテムが出力された                   |
| `tool_output`             | ツールの結果アイテムが出力された                     |
| `reasoning_item_created`  | リーズニングアイテムが出力された                     |
| `tool_approval_requested` | ツール呼び出しが人による承認のために一時停止した     |

ハンドオフのペイロード例:

```json
{
  "type": "run_item_stream_event",
  "name": "handoff_occurred",
  "item": {
    "type": "handoff_call",
    "id": "h1",
    "status": "completed",
    "name": "transfer_to_refund_agent"
  }
}
```

### agent_updated_stream_event

```ts
type RunAgentUpdatedStreamEvent = {
  type: 'agent_updated_stream_event';
  agent: Agent<any, any>;
};
```

例:

```json
{
  "type": "agent_updated_stream_event",
  "agent": {
    "name": "Refund Agent"
  }
}
```

## ストリーミング中の Human in the loop（人間の介入）

ストリーミングは、実行を一時停止するハンドオフ（例えばツールが承認を必要とする場合）と互換性があります。ストリームオブジェクト上の `interruption` フィールドで割り込みにアクセスでき、各割り込みに対して `state.approve()` または `state.reject()` を呼び出すことで実行を継続できます。`{ stream: true }` で再実行するとストリーミング出力が再開します。

<Code
  lang="typescript"
  code={streamedHITLExample}
  title="Handling human approval while streaming"
/>

ユーザー と対話する、より完全な code examples は [`human-in-the-loop-stream.ts`](https://github.com/openai/openai-agents-js/tree/main/examples/agent-patterns/human-in-the-loop-stream.ts) を参照してください。

## ヒント

- すべての出力がフラッシュされることを確実にするため、終了前に `stream.completed` を待つことを忘れないでください
- 最初の `{ stream: true }` オプションは、それを指定した呼び出しにのみ適用されます。`RunState` で再実行する場合は、再度このオプションを指定する必要があります
- アプリケーションがテキスト結果のみに関心がある場合は、個々のイベントオブジェクトを扱わずに済むように `toTextStream()` を優先してください

ストリーミングとイベントシステムを使うことで、エージェントをチャットインターフェースやターミナルアプリケーション、増分更新が ユーザー に有益なあらゆる場面に統合できます。
