---
title: 音声エージェントの構築
description: Learn how to build voice agents using the OpenAI Agents SDK, what features are available, how to architecture your application, and more.
---

import { Steps, Aside, Code } from '@astrojs/starlight/components';
import createAgentExample from '../../../../../../../examples/docs/voice-agents/createAgent.ts?raw';
import multiAgentsExample from '../../../../../../../examples/docs/voice-agents/multiAgents.ts?raw';
import createSessionExample from '../../../../../../../examples/docs/voice-agents/createSession.ts?raw';
import configureSessionExample from '../../../../../../../examples/docs/voice-agents/configureSession.ts?raw';
import handleAudioExample from '../../../../../../../examples/docs/voice-agents/handleAudio.ts?raw';
import defineToolExample from '../../../../../../../examples/docs/voice-agents/defineTool.ts?raw';
import toolApprovalEventExample from '../../../../../../../examples/docs/voice-agents/toolApprovalEvent.ts?raw';
import guardrailsExample from '../../../../../../../examples/docs/voice-agents/guardrails.ts?raw';
import guardrailSettingsExample from '../../../../../../../examples/docs/voice-agents/guardrailSettings.ts?raw';
import audioInterruptedExample from '../../../../../../../examples/docs/voice-agents/audioInterrupted.ts?raw';
import sessionInterruptExample from '../../../../../../../examples/docs/voice-agents/sessionInterrupt.ts?raw';
import sessionHistoryExample from '../../../../../../../examples/docs/voice-agents/sessionHistory.ts?raw';
import historyUpdatedExample from '../../../../../../../examples/docs/voice-agents/historyUpdated.ts?raw';
import updateHistoryExample from '../../../../../../../examples/docs/voice-agents/updateHistory.ts?raw';
import customWebRTCTransportExample from '../../../../../../../examples/docs/voice-agents/customWebRTCTransport.ts?raw';
import websocketSessionExample from '../../../../../../../examples/docs/voice-agents/websocketSession.ts?raw';
import transportEventsExample from '../../../../../../../examples/docs/voice-agents/transportEvents.ts?raw';
import thinClientExample from '../../../../../../../examples/docs/voice-agents/thinClient.ts?raw';
import toolHistoryExample from '../../../../../../../examples/docs/voice-agents/toolHistory.ts?raw';
import sendMessageExample from '../../../../../../../examples/docs/voice-agents/sendMessage.ts?raw';
import serverAgentExample from '../../../../../../../examples/docs/voice-agents/serverAgent.ts?raw';
import delegationAgentExample from '../../../../../../../examples/docs/voice-agents/delegationAgent.ts?raw';
import turnDetectionExample from '../../../../../../../examples/docs/voice-agents/turnDetection.ts?raw';

<Aside type="caution">

アーキテクチャは早めに選んでください:

- `OpenAIRealtimeWebRTC` はブラウザで最もシンプルな方法で、音声入力 / 出力を自動で処理します
- `OpenAIRealtimeWebSocket` はより細かく制御できますが、音声のキャプチャと再生は自分で管理する必要があります
- 関数ツールは `RealtimeSession` が動作している場所で実行されます。セッションがブラウザで動作している場合、ツールもブラウザで実行されます
- Realtime ハンドオフでは同じ音声とモデルが維持されます。別のバックエンドモデルが必要な場合は、ハンドオフではなくツール経由で委譲してください

</Aside>

## セッション設定

### 音声処理

デフォルトの `OpenAIRealtimeWebRTC` のような一部のトランスポートレイヤーでは、音声入力と出力を
自動的に処理します。`OpenAIRealtimeWebSocket` のようなほかのトランスポートでは、
セッション音声を自分で処理する必要があります:

<Code lang="typescript" code={handleAudioExample} />

基盤となるトランスポートが対応している場合、`session.muted` は現在のミュート状態を返し、
`session.mute(true | false)` でマイク入力の有効 / 無効を切り替えます。`OpenAIRealtimeWebSocket` は
ミュートを実装していません: `session.muted` は `null` を返し、`session.mute()` は例外を投げます。したがって WebSocket
構成では、ユーザー側でキャプチャを停止し、マイクを再び有効にするまで `sendAudio()` の呼び出しを止めてください。

### セッション構成

[`RealtimeSession`](/openai-agents-js/openai/agents-realtime/classes/realtimesession/) の構築時、または
`connect(...)` の呼び出し時に追加オプションを渡してセッションを構成できます。

<Code lang="typescript" code={configureSessionExample} />

これらのトランスポートレイヤーでは、[session](https://platform.openai.com/docs/api-reference/realtime-client-events/session/update) に一致する任意のパラメーターを渡せます。

新しい設定形式である `outputModalities`、`audio.input`、`audio.output` の利用を推奨します。レガシーな
トップレベルフィールド（`modalities`、`inputAudioFormat`、`outputAudioFormat`、
`inputAudioTranscription`、`turnDetection`）は後方互換性のため引き続き正規化されますが、
新しいコードではここで示すネストされた `audio` 構造を使ってください。

新しいパラメーターで [RealtimeSessionConfig](/openai-agents-js/openai/agents-realtime/type-aliases/realtimesessionconfig/) に対応項目がない場合は、`providerData` を使えます。`providerData` に渡したものはすべて `session` オブジェクトの一部として直接渡されます。

構築時に設定できる追加の `RealtimeSession` オプション:

| Option                                        | Type                              | Purpose                                                                                               |
| --------------------------------------------- | --------------------------------- | ----------------------------------------------------------------------------------------------------- |
| `context`                                     | `TContext`                        | セッションコンテキストにマージされる追加のローカルコンテキスト                                        |
| `historyStoreAudio`                           | `boolean`                         | ローカル履歴スナップショットに音声データを保存（デフォルトでは無効）                                  |
| `outputGuardrails`                            | `RealtimeOutputGuardrail[]`       | セッションの出力ガードレール（[Guardrails](#guardrails) を参照）                                      |
| `outputGuardrailSettings`                     | `{ debounceTextLength?: number }` | ガードレール実行間隔。デフォルトは `100`。全文が利用可能になってから 1 回だけ実行するには `-1` を使用 |
| `tracingDisabled`                             | `boolean`                         | セッションのトレーシングを無効化                                                                      |
| `groupId`                                     | `string`                          | セッション間またはバックエンド実行間でトレースをグループ化                                            |
| `traceMetadata`                               | `Record<string, any>`             | セッショントレースに付与するカスタムメタデータ                                                        |
| `workflowName`                                | `string`                          | トレースワークフローの表示名                                                                          |
| `automaticallyTriggerResponseForMcpToolCalls` | `boolean`                         | MCP ツール呼び出し完了時にモデル応答を自動トリガー（デフォルト: `true`）                              |
| `toolErrorFormatter`                          | `ToolErrorFormatter`              | モデルへ返すツール承認拒否メッセージをカスタマイズ                                                    |

`connect(...)` オプション:

| Option   | Type                                          | Purpose                                           |
| -------- | --------------------------------------------- | ------------------------------------------------- |
| `apiKey` | `string \| (() => string \| Promise<string>)` | この接続で使用する API キー（または遅延ローダー） |
| `model`  | `OpenAIRealtimeModels \| string`              | トランスポート接続用の任意のモデル上書き          |
| `url`    | `string`                                      | 任意のカスタム Realtime エンドポイント URL        |
| `callId` | `string`                                      | 既存の SIP 開始済み通話 / セッションにアタッチ    |

## エージェント機能

### ハンドオフ

通常のエージェントと同様に、ハンドオフを使ってエージェントを複数に分割し、それらをオーケストレーションできます。これによりエージェントの性能を高め、問題のスコープをより適切にできます。

<Code lang="typescript" code={multiAgentsExample} />

通常のエージェントと異なり、Realtime Agents のハンドオフは少し挙動が異なります。ハンドオフが実行されると、進行中のセッションは新しいエージェント構成で更新されます。このため、エージェントは進行中の会話履歴に自動的にアクセスでき、現在は入力フィルターは適用されません。

さらに、ハンドオフの一部として `voice` や `model` は変更できません。また、接続先はほかの Realtime Agents のみです。たとえば `gpt-5.2` のような推論モデルを使いたい場合は、[delegation through tools](#delegation-through-tools) を利用してください。

### ツール

通常のエージェントと同様に、Realtime Agents はツール呼び出しでアクションを実行できます。Realtime は **関数ツール**（ローカル実行）と **hosted MCP tools**（Realtime API によりリモート実行）をサポートします。関数ツールは通常のエージェントで使うのと同じ `tool()` ヘルパーで定義できます。

<Code lang="typescript" code={defineToolExample} />

#### 関数ツール

関数ツールは `RealtimeSession` と同じ環境で実行されます。つまり、セッションをブラウザで実行している場合、ツールもブラウザで実行されます。機密性の高い処理が必要な場合は、ツール内からバックエンドを呼び出し、特権処理はサーバーで実行してください。

これにより、ブラウザ側ツールをサーバー側ロジックへの薄いバックチャネルとして使えます。たとえば [`examples/realtime-next`](https://github.com/openai/openai-agents-js/tree/main/examples/realtime-next) では、ブラウザで `refundBackchannel` ツールを定義し、リクエストと現在の会話履歴をサーバーの `handleRefundRequest(...)` に転送します。サーバー側では別の `Runner` が別エージェントや別モデルを使って返金判断を行い、その結果を音声セッションへ返します。

#### Hosted MCP ツール

Hosted MCP ツールは `hostedMcpTool` で構成でき、リモートで実行されます。MCP ツールの利用可否が変わると、セッションは `mcp_tools_changed` を発行します。MCP ツール呼び出し完了後のモデル応答自動トリガーを防ぐには、`automaticallyTriggerResponseForMcpToolCalls: false` を設定してください。

現在フィルター済みの MCP ツール一覧は `session.availableMcpTools` としても利用できます。この
プロパティと `mcp_tools_changed` イベントはどちらも、アクティブなエージェントで有効な hosted MCP サーバーのみを反映し、
エージェント構成の `allowed_tools` フィルター適用後の結果です。

#### バックグラウンド結果

ツール実行中、エージェントはユーザーからの新しいリクエストを処理できません。体験を改善する 1 つの方法は、ツール実行前に案内するようエージェントに指示したり、実行時間を稼ぐ定型句を話させたりすることです。

関数ツールが、直後に別のモデル応答をトリガーせず完了すべき場合は、`@openai/agents/realtime` の `backgroundResult(output)` を返してください。
これにより、ツール出力をセッションへ返しつつ、応答トリガーはユーザー側で制御できます。

#### タイムアウト

関数ツールのタイムアウトオプション（`timeoutMs`、`timeoutBehavior`、`timeoutErrorFunction`）は Realtime セッションでも同様に機能します。デフォルトの `error_as_result` では、タイムアウトメッセージがツール出力として送信されます。`raise_exception` では、セッションが [`ToolTimeoutError`](/openai-agents-js/openai/agents-core/classes/tooltimeouterror) を伴う `error` イベントを発行し、その呼び出しのツール出力は送信されません。

#### 会話履歴へのアクセス

エージェントが特定ツールを呼び出した引数に加えて、Realtime Session が追跡している現在の会話履歴スナップショットにもアクセスできます。これは、会話の現在状態に基づいてより複雑な処理を行う場合や、[tools for delegation](#delegation-through-tools) を使う予定がある場合に有用です。

<Code lang="typescript" code={toolHistoryExample} />

<Aside type="note">
  渡される履歴は、ツール呼び出し時点のスナップショットです。ユーザーが最後に話した内容の
  文字起こしは、まだ利用できない場合があります。
</Aside>

#### ツール実行前の承認

ツールを `needsApproval: true` で定義すると、エージェントはツール実行前に `tool_approval_requested` イベントを発行します。

このイベントを監視することで、ツール呼び出しを承認 / 拒否する UI をユーザーに表示できます。

<Code lang="typescript" code={toolApprovalEventExample} />

<Aside type="note">
  音声エージェントがツール呼び出し承認待ちの間、エージェントはユーザーからの新しいリクエストを
  処理できません。
</Aside>

### ガードレール

ガードレールは、エージェントの発話がルール違反かどうかを監視し、応答を即時に遮断する方法を提供します。これらのガードレールチェックはエージェント応答の文字起こしに基づいて実行されるため、モデルのテキスト出力が有効である必要があります（デフォルトで有効）。

提供したガードレールはモデル応答の返却中に非同期で実行されるため、たとえば「特定の禁止語を含む」のような事前定義の分類トリガーに基づいて応答を遮断できます。

ガードレールが発火すると、セッションは `guardrail_tripped` イベントを発行します。イベントには、ガードレールを発火させた `itemId` を含む `details` オブジェクトも含まれます。

<Code lang="typescript" code={guardrailsExample} />

デフォルトでは、ガードレールは 100 文字ごとに実行され、さらに最終文字起こしが利用可能になった時点でも実行されます。通常、テキストを読み上げる時間は文字起こし生成より長いため、ユーザーが聞く前に危険な出力を遮断できることがよくあります。

この挙動を変更したい場合は、セッションに `outputGuardrailSettings` オブジェクトを渡せます。

応答の最後に、完全生成された文字起こしを 1 回だけ評価したい場合は、`debounceTextLength: -1` を設定してください。

<Code lang="typescript" code={guardrailSettingsExample} />

## インタラクションフロー

### ターン検出 / 音声アクティビティ検出

Realtime Session は、組み込みの [Realtime API の voice activity detection modes](https://platform.openai.com/docs/guides/realtime-vad) を使用して、ユーザーの発話を自動検出し、新しいターンをトリガーします。

セッション設定の `audio.input.turnDetection` を渡すことで、
voice activity detection モードを変更できます。

<Code lang="typescript" code={turnDetectionExample} />

ターン検出設定の調整は、不要な割り込みの抑制や無音への対処に役立ちます。各設定の詳細は [Realtime API documentation for more details on the different settings](https://platform.openai.com/docs/guides/realtime-vad) を確認してください

### 割り込み

組み込みの voice activity detection を使用している場合、エージェントに重ねて話すと、
エージェントは発話内容を検出し、コンテキストを自動更新します。同時に
`audio_interrupted` イベントも発行されます。これを使って、すべての音声再生を即時停止できます（WebSocket 接続の場合のみ）。

<Code lang="typescript" code={audioInterruptedExample} />

手動で割り込みたい場合（たとえば UI に「停止」ボタンを提供したい場合）は、
`interrupt()` を手動で呼び出せます:

<Code lang="typescript" code={sessionInterruptExample} />

どちらの場合でも、Realtime Session はエージェント生成の中断、ユーザーに対して話された内容の認識範囲の切り詰め、履歴更新を処理します。

WebRTC でエージェントへ接続している場合は、音声出力もクリアされます。WebSocket を使用している場合は、キュー済みの音声再生を停止するなど、この処理を自分で行う必要があります。

### テキスト入力

エージェントにテキスト入力を送信したい場合は、`RealtimeSession` の `sendMessage` メソッドを使えます。

これは、ユーザーがエージェントと両モダリティでやり取りできるようにしたい場合や、
会話に追加コンテキストを提供したい場合に有用です。

<Code lang="typescript" code={sendMessageExample} />

## 会話状態と委譲

### 会話履歴管理

`RealtimeSession` は `history` プロパティで会話履歴を自動管理します:

これを使って履歴を顧客に表示したり、追加処理を実行したりできます。この
履歴は会話中に継続的に変化するため、`history_updated` イベントを監視できます。

メッセージ全体の削除や文字起こし更新など、履歴を変更したい場合は
`updateHistory` メソッドを使えます。

<Code lang="typescript" code={updateHistoryExample} />

#### 制限事項

1. 現時点では、関数ツール呼び出しは事後に更新 / 変更できません
2. 履歴内のテキスト出力には、transcript と text modalities の有効化が必要です
3. 割り込みにより切り詰められた応答には transcript がありません

### ツールによる委譲

![Delegation through tools](https://cdn.openai.com/API/docs/diagram-speech-to-speech-agent-tools.png)

会話履歴とツール呼び出しを組み合わせることで、より複雑な処理を実行するために会話を別のバックエンドエージェントへ委譲し、その結果をユーザーへ返せます。

<Code lang="typescript" code={delegationAgentExample} />

その後、以下のコードがサーバー上で実行されます。この例では Next.js の server actions を使います。

<Code lang="typescript" code={serverAgentExample} />
