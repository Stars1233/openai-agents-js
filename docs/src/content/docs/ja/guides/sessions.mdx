---
title: セッション
description: Persist multi-turn conversation history so agents can resume context across runs.
---

import { Code } from '@astrojs/starlight/components';
import sessionsQuickstart from '../../../../../../examples/docs/sessions/basicSession.ts?raw';
import manageHistory from '../../../../../../examples/docs/sessions/manageHistory.ts?raw';
import customSession from '../../../../../../examples/docs/sessions/customSession.ts?raw';
import sessionInputCallback from '../../../../../../examples/docs/sessions/sessionInputCallback.ts?raw';
import responsesCompactionSession from '../../../../../../examples/docs/sessions/responsesCompactionSession.ts?raw';
import manualCompactionSession from '../../../../../../examples/docs/sessions/responsesCompactionManualSession.ts?raw';
import memorySessionExample from '../../../../../../examples/docs/sessions/memorySession.ts?raw';
import resumableRunExample from '../../../../../../examples/docs/sessions/resumableRun.ts?raw';

セッションは Agents SDK に **永続的なメモリレイヤー** を提供します。`Session` インターフェースを実装した任意のオブジェクトを `Runner.run` に渡せば、あとは SDK が処理します。セッションがある場合、ランナーは自動的に次を行います。

1. 以前に保存された会話アイテムを取得し、次のターンの先頭に追加します
2. 各実行完了後に、新しいユーザー入力とアシスタント出力を永続化します
3. 新しいユーザーテキストでランナーを呼び出す場合でも、中断された `RunState` から再開する場合でも、将来のターンに向けてセッションを利用可能な状態に保ちます

これにより、`toInputList()` を手動で呼び出したり、ターン間で履歴をつなぎ合わせたりする必要がなくなります。 TypeScript SDK には 2 つの実装があります。Conversations API 向けの `OpenAIConversationsSession` と、ローカル開発向けの `MemorySession` です。どちらも `Session` インターフェースを共有しているため、独自のストレージバックエンドを差し替えられます。Conversations API 以外の実装例は、`examples/memory/` 配下のサンプルセッションバックエンド（Prisma、ファイルベースなど）を参照してください。OpenAI Responses モデルを使う場合は、任意のセッションを `OpenAIResponsesCompactionSession` でラップすると、[`responses.compact`](https://platform.openai.com/docs/api-reference/responses/compact) により保存済み会話履歴を自動で縮小できます。

> ヒント: このページの `OpenAIConversationsSession` の例を実行するには、`OPENAI_API_KEY` 環境変数を設定するか（またはセッション構築時に `apiKey` を渡し）、SDK が Conversations API を呼び出せるようにしてください。

セッションは、SDK にクライアント側メモリ管理を任せたい場合に使います。すでに
`conversationId` や `previousResponseId` を使って OpenAI のサーバー管理状態を利用している場合は、通常、同じ会話履歴に対してセッションを追加で使う必要はありません。

---

## はじめに

### クイックスタート

`OpenAIConversationsSession` を使うと [Conversations API](https://platform.openai.com/docs/api-reference/conversations) とメモリを同期できます。あるいは他の `Session` 実装に差し替えることもできます。

<Code
  lang="typescript"
  code={sessionsQuickstart}
  title="Use the Conversations API as session memory"
/>

同じセッションインスタンスを再利用すると、エージェントは毎ターン前に会話履歴全体を受け取り、新しいアイテムも自動で永続化されます。別の `Session` 実装への切り替えに、他のコード変更は不要です。

ローカルデモ、テスト、またはプロセスローカルなチャット状態には、`MemorySession` が OpenAI と通信せずに同じインターフェースを提供します。

<Code
  lang="typescript"
  code={memorySessionExample}
  title="Use MemorySession for local state"
/>

`OpenAIConversationsSession` のコンストラクターオプション:

| Option           | Type     | Notes                                         |
| ---------------- | -------- | --------------------------------------------- |
| `conversationId` | `string` | 遅延作成する代わりに既存の会話を再利用します  |
| `client`         | `OpenAI` | 事前設定済みの OpenAI クライアントを渡します  |
| `apiKey`         | `string` | 内部 OpenAI クライアント作成時に使う API キー |
| `baseURL`        | `string` | OpenAI 互換エンドポイント向けの Base URL      |
| `organization`   | `string` | リクエストに使用する OpenAI organization ID   |
| `project`        | `string` | リクエストに使用する OpenAI project ID        |

`MemorySession` のコンストラクターオプション:

| Option         | Type               | Notes                                                          |
| -------------- | ------------------ | -------------------------------------------------------------- |
| `sessionId`    | `string`           | ログやテスト用の安定した識別子。デフォルトでは自動生成されます |
| `initialItems` | `AgentInputItem[]` | 既存履歴でセッションを初期化します                             |
| `logger`       | `Logger`           | デバッグ出力に使うロガーを上書きします                         |

`MemorySession` はすべてをローカルプロセスメモリに保存するため、プロセス終了時にリセットされます。

セッション構築前に会話 ID を事前作成する必要がある場合は、
`startOpenAIConversationsSession(client?)` を使い、返された ID を `conversationId` として渡してください。

---

## セッションのコア動作

### ランナーによるセッション利用

- **各実行前** にセッション履歴を取得し、新しいターン入力とマージして、結合リストをエージェントに渡します
- **非ストリーミング実行後** は `session.addItems()` の 1 回の呼び出しで、元のユーザー入力と最新ターンのモデル出力の両方を永続化します
- **ストリーミング実行では** 先にユーザー入力を書き込み、ターン完了後にストリーミング出力を追記します
- **`RunResult.state` から再開する場合**（承認などの中断時）は、同じ `session` を渡し続けます。再開ターンは入力再準備なしでメモリに追加されます

---

### 履歴の確認と編集

セッションはシンプルな CRUD ヘルパーを公開しており、「取り消し」「チャットクリア」「監査」機能を構築できます。

<Code
  lang="typescript"
  code={manageHistory}
  title="Read and edit stored items"
/>

`session.getItems()` は保存済みの `AgentInputItem[]` を返します。`popItem()` を呼び出すと最後のエントリを削除できます。エージェント再実行前のユーザー修正に便利です。

---

## カスタムストレージとマージ動作

### 独自ストレージの利用

`Session` インターフェースを実装すると、Redis、DynamoDB、SQLite など任意のデータストアでメモリを管理できます。必要なのは 5 つの非同期メソッドだけです。

<Code
  lang="typescript"
  code={customSession}
  title="Custom in-memory session implementation"
/>

カスタムセッションを使うと、保持ポリシーの適用、暗号化の追加、永続化前に各会話ターンへメタデータを付与することができます。

---

### 履歴と新規アイテムのマージ制御

実行入力として `AgentInputItem` の配列を渡す場合は、`sessionInputCallback` を提供して保存済み履歴とのマージを決定論的に行ってください。ランナーは既存履歴を読み込み、**モデル呼び出し前** にコールバックを実行し、返された配列をターンの完全な入力としてモデルに渡します。このフックは、古いアイテムのトリミング、ツール結果の重複排除、モデルに見せたいコンテキストだけの強調に最適です。

<Code
  lang="typescript"
  code={sessionInputCallback}
  title="Truncate history with sessionInputCallback"
/>

文字列入力の場合、ランナーは履歴を自動でマージするため、コールバックは任意です。コールバックは、ターン入力がすでにアイテム配列の場合にのみ実行されます。

---

## 再開可能な実行

### 承認と再開可能な実行の処理

Human-in-the-loop フローでは、承認待ちのために実行を一時停止することがよくあります。

<Code
  lang="typescript"
  code={resumableRunExample}
  title="Resume a run with the same session"
/>

以前の `RunState` から再開すると、新しいターンは同じメモリレコードに追記され、単一の会話履歴が保たれます。Human-in-the-loop (HITL) フローとの互換性も完全に維持されます。承認チェックポイントは引き続き `RunState` を往復しつつ、セッションが会話履歴の完全性を保ちます。

---

## 高度な機能: 履歴の圧縮

### OpenAI Responses 履歴の自動圧縮

`OpenAIResponsesCompactionSession` は任意の `Session` をデコレートし、OpenAI Responses API を使って長い保存履歴を同等でより短い会話アイテムリストに置き換えます。各ターンの永続化後、ランナーは最新の `responseId` を `runCompaction` に渡し、判定フックが true を返した場合に `responses.compact` を呼び出します。`compactionMode` に応じて、リクエストは最新の Responses API チェーンまたはセッションの現在アイテムから構築されます。デフォルトのトリガーは、ユーザー以外のアイテムが 10 件以上蓄積した時点で圧縮します。`shouldTriggerCompaction` を上書きすれば、トークン数や独自ヒューリスティクスに基づいて判定できます。圧縮完了後、デコレーターは基盤セッションをクリアして圧縮後リストで再書き込みします。そのため、異なるサーバー管理履歴フローを使う `OpenAIConversationsSession` との併用は避けてください。

<Code
  lang="typescript"
  code={responsesCompactionSession}
  title="Decorate a session with OpenAIResponsesCompactionSession"
/>

`OpenAIResponsesCompactionSession` のコンストラクターオプション:

| Option                    | Type                                          | Notes                                                                                                                |
| ------------------------- | --------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- |
| `client`                  | `OpenAI`                                      | `responses.compact` に使用する OpenAI クライアント                                                                   |
| `underlyingSession`       | `Session`                                     | 圧縮済みアイテムでクリア/再書き込みする基盤セッションストア（`OpenAIConversationsSession` 以外である必要があります） |
| `model`                   | `OpenAI.ResponsesModel`                       | 圧縮リクエストに使うモデル                                                                                           |
| `compactionMode`          | `'auto' \| 'previous_response_id' \| 'input'` | 圧縮にサーバーレスポンスチェーンを使うか、ローカル入力アイテムを使うかを制御します                                   |
| `shouldTriggerCompaction` | `(context) => boolean \| Promise<boolean>`    | `responseId`、`compactionMode`、候補アイテム、現在のセッションアイテムに基づくカスタムトリガーフック                 |

`compactionMode: 'previous_response_id'` は、すでに
Responses API の response ID でターンを連結している場合に有用です。`compactionMode: 'input'` は代わりに現在の
セッションアイテムから圧縮リクエストを再構築するため、response チェーンが使えない場合や、
基盤セッション内容を信頼できる唯一の情報源にしたい場合に便利です。

`runCompaction(args)` のオプション:

| Option           | Type                                          | Notes                                                           |
| ---------------- | --------------------------------------------- | --------------------------------------------------------------- |
| `responseId`     | `string`                                      | `previous_response_id` モード用の最新 Responses API response id |
| `compactionMode` | `'auto' \| 'previous_response_id' \| 'input'` | 設定モードを呼び出し単位で上書きする任意オプション              |
| `store`          | `boolean`                                     | 直前の実行でサーバー状態を保存したかどうかを示します            |
| `force`          | `boolean`                                     | `shouldTriggerCompaction` をバイパスして即時圧縮します          |

#### 低遅延ストリーミング向け手動圧縮

圧縮は基盤セッションをクリアして再書き込みするため、SDK はストリーミング実行を解決する前に圧縮完了を待ちます。圧縮が重い場合、最後の出力トークン後も `result.completed` が数秒待機することがあります。低遅延ストリーミングや高速なターン切り替えが必要な場合は、自動圧縮を無効化し、ターン間（またはアイドル時間）に `runCompaction` を自分で呼び出してください。

<Code
  lang="typescript"
  code={manualCompactionSession}
  title="Disable auto-compaction and compact between turns"
/>

`runCompaction({ force: true })` はいつでも呼び出せるため、アーカイブやハンドオフ前に履歴を縮小できます。`DEBUG=openai-agents:openai:compaction` でデバッグログを有効にすると、圧縮判定を追跡できます。
