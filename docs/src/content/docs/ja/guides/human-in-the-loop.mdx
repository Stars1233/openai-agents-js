---
title: 人間の介入（HITL）
description: Add a human in the loop check for your agent executions
---

import { Aside, Code } from '@astrojs/starlight/components';
import humanInTheLoopExample from '../../../../../../examples/docs/human-in-the-loop/index.ts?raw';
import toolApprovalDefinition from '../../../../../../examples/docs/human-in-the-loop/toolApprovalDefinition.ts?raw';

このガイドでは、SDK に組み込まれた Human in the loop (人間の介入) サポートを使用して、人の介入に基づいてエージェントの実行を一時停止および再開する方法を示します。

現時点での主なユースケースは、機密性の高いツール実行に対する承認を求めることです。

## 承認リクエスト

`needsApproval` オプションを `true`、または真偽値を返す非同期関数に設定することで、承認が必要なツールを定義できます。

<Code
  lang="typescript"
  code={toolApprovalDefinition}
  title="ツール承認の定義"
  meta={`{10}`}
/>

### フロー

1. エージェントがツール（複数可）を呼び出すと判断した場合、`needsApproval` を評価してそのツールに承認が必要か確認します
2. 承認が必要な場合、エージェントは承認がすでに許可または拒否されているかを確認します
   - 承認が許可も拒否もされていない場合、ツールはツール呼び出しを実行できないという固定メッセージをエージェントに返します
   - 承認 / 拒否が未設定の場合、ツール承認リクエストがトリガーされます
3. エージェントはすべてのツール承認リクエストを収集し、実行を中断します
4. 中断がある場合、[エージェントの実行結果](/openai-agents-js/ja/guides/results) に、保留中のステップを示す `interruptions` 配列が含まれます。ツール呼び出しに確認が必要なときは、`type: "tool_approval_item"` を持つ `ToolApprovalItem` が表示されます
5. ツール呼び出しを承認または拒否するには、`result.state.approve(interruption)` または `result.state.reject(interruption)` を呼び出します。同じツールをその実行の残りの間ずっと承認または拒否状態にしたい場合は、`{ alwaysApprove: true }` または `{ alwaysReject: true }` を渡します
6. すべての中断を処理したら、`result.state` を `runner.run(agent, state)` に渡して実行を再開できます。ここで `agent` は全体の実行をトリガーした元のエージェントです
7. フローは手順 1 から再開されます

## 例

以下は、ターミナルで承認を促し、状態を一時的にファイルに保存する Human in the loop (人間の介入) フローの、より完全な例です。

<Code
  lang="typescript"
  code={humanInTheLoopExample}
  title="Human in the loop (人間の介入)"
/>

エンドツーエンドで動作するバージョンは、[the full example script](https://github.com/openai/openai-agents-js/tree/main/examples/agent-patterns/human-in-the-loop.ts) を参照してください。

## 長い承認時間への対応

Human in the loop (人間の介入) フローは、サーバーを稼働させ続けることなく長時間中断可能なように設計されています。リクエストを一旦終了して後で続行する必要がある場合、状態をシリアライズして後で再開できます。

`result.state.toString()`（または `JSON.stringify(result.state)`）で状態をシリアライズし、シリアライズ済み状態を `RunState.fromString(agent, serializedState)` に渡すことで後から再開できます。ここで `agent` は全体の実行をトリガーしたエージェントのインスタンスです。

再開時に新しいコンテキストオブジェクトを挿入する必要がある場合は、代わりに `RunState.fromStringWithContext(agent, serializedState, context, { contextStrategy })` を使用してください。

- `contextStrategy: 'merge'`（デフォルト）は、シリアライズされた承認状態を保持し、提供された `RunContext` にマージします
- `contextStrategy: 'replace'` は、提供された `RunContext` をそのまま使用して実行を再構築します

デフォルトでは、トレーシング API キーはシリアライズされた状態から省かれるため、機密情報を誤って永続化しないようになっています。状態と一緒にトレーシングの認証情報を移動する必要がある場合にのみ、`result.state.toString({ includeTracingApiKey: true })` を渡してください。

この方法により、シリアライズ済み状態をデータベースやリクエストと一緒に保存できます。

### 保留タスクのバージョニング

<Aside>
  これは主に、エージェントに変更を加えつつ、シリアライズ済み状態を
  長期間保存しようとしている場合に当てはまります。
</Aside>

承認リクエストに長時間かかり、エージェント定義を意味のある形でバージョン管理したい、あるいは Agents SDK のバージョンを上げたい場合は、現時点ではパッケージエイリアスを使用して 2 つのバージョンの Agents SDK を並行インストールし、独自の分岐ロジックを実装することをおすすめします。

実務上は、自分のコードにバージョン番号を割り当て、それをシリアライズ済み状態と一緒に保存し、デシリアライズを正しいコードのバージョンに誘導することを意味します。
