---
title: マルチエージェント
description: Coordinate the flow between several agents
---

オーケストレーションとは、アプリ内でのエージェントの流れを指します。どのエージェントを、どの順序で実行し、次に何を行うかをどのように決定するか、ということです。エージェントをオーケストレーションする主な方法は 2 つあります。

1. LLM に意思決定を任せる: LLM の知能を使って計画・推論を行い、それに基づいて実行ステップを決定します
2. コードでオーケストレーションする: コードによってエージェントの流れを決定します

これらのパターンは組み合わせて使えます。それぞれにトレードオフがあり、以下で説明します。

## LLM によるオーケストレーション

エージェントとは、instructions、ツール、ハンドオフを備えた LLM です。つまり、オープンエンドなタスクが与えられたとき、LLM はタスクへの取り組み方を自律的に計画できます。ツールを使ってアクションを実行しデータを取得し、ハンドオフを使ってサブエージェントにタスクを委任できます。たとえば、リサーチ用エージェントには次のようなツールを持たせられます。

- オンラインで情報を見つけるための Web 検索
- 独自データや接続先を検索するためのファイル検索と取得
- コンピュータ上で操作を行うためのコンピュータ操作
- データ分析を行うためのコード実行
- 計画立案、レポート作成などに特化したエージェントへのハンドオフ

### SDK の中核パターン

Agents SDK では、次の 2 つのオーケストレーションパターンが特によく使われます。

| Pattern         | How it works                                                                                                                   | Best when                                                                                                                                              |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Agents as tools | マネージャーエージェントが会話の制御を維持し、`agent.asTool()` を通じて専門エージェントを呼び出します。                        | 1 つのエージェントに最終回答を担当させたい場合、複数の専門エージェントの出力を統合したい場合、または共通のガードレールを 1 か所で適用したい場合        |
| Handoffs        | トリアージエージェントが会話を専門エージェントにルーティングし、その専門エージェントがそのターンの残りでアクティブになります。 | 専門エージェントにユーザーへ直接応答させたい場合、プロンプトを絞り込みたい場合、または専門エージェントごとに異なる instructions / モデルを使いたい場合 |

専門エージェントにサブタスクを手伝わせたいが、ユーザー向け会話は引き継がせたくない場合は **Agents as tools** を使います。どのツールを呼び出すか、最終応答をどう提示するかの責任はマネージャーが持ち続けます。API の詳細は [ツール](/openai-agents-js/ja/guides/tools#agents-as-tools)、並列比較の例は [エージェント](/openai-agents-js/ja/guides/agents#composition-patterns) を参照してください。

ルーティング自体がワークフローの一部で、選ばれた専門エージェントに会話の次の部分を担当させたい場合は **ハンドオフ** を使います。ハンドオフは会話コンテキストを保持しつつ、アクティブな instructions を専門エージェント向けに絞り込みます。API は [ハンドオフ](/openai-agents-js/ja/guides/handoffs)、最小のエンドツーエンド例は [クイックスタート](/openai-agents-js/ja/guides/quickstart#define-your-handoffs) を参照してください。

この 2 つのパターンは組み合わせ可能です。トリアージエージェントが専門エージェントへハンドオフし、その専門エージェントがさらに別のエージェントをツールとして使って、境界の明確なサブタスクを処理できます。

このパターンは、タスクがオープンエンドで、LLM の知能を活用したい場合に非常に有効です。特に重要な戦術は次のとおりです。

1. 良いプロンプトに投資すること。利用可能なツール、使い方、守るべきパラメーター範囲を明確にすること
2. アプリを監視して反復改善すること。どこで問題が起きるかを把握し、プロンプトを改善すること
3. エージェントに内省と改善をさせること。たとえばループで実行し自己批評させる、またはエラーメッセージを与えて改善させること
4. 何でもできる汎用エージェント 1 つより、単一タスクに強い専門エージェントを用意すること
5. [evals](https://platform.openai.com/docs/guides/evals) に投資すること。これにより、エージェントを改善し、タスク性能を高められます

このスタイルのオーケストレーションを支える SDK の基本コンポーネントを知りたい場合は、[ツール](/openai-agents-js/ja/guides/tools)、[ハンドオフ](/openai-agents-js/ja/guides/handoffs)、[エージェントの実行](/openai-agents-js/ja/guides/running-agents) から始めてください。

## コードによるオーケストレーション

LLM によるオーケストレーションは強力ですが、コードによるオーケストレーションは、速度・コスト・性能の面でより決定的かつ予測可能になります。ここでの一般的なパターンは次のとおりです。

- [structured outputs](https://platform.openai.com/docs/guides/structured-outputs) を使って、コードで検査できる適切な形式のデータを生成する。たとえば、タスクをいくつかのカテゴリーに分類させ、そのカテゴリーに基づいて次のエージェントを選ぶ
- 複数のエージェントを連鎖させ、あるエージェントの出力を次の入力に変換する。たとえばブログ記事作成を、リサーチ、アウトライン作成、本文作成、批評、改善という一連のステップに分解する
- タスク実行エージェントを、評価とフィードバックを行うエージェントとともに `while` ループで実行し、評価エージェントが出力が基準を満たしたと判断するまで繰り返す
- 複数のエージェントを並列実行する。たとえば `Promise.all` のような JavaScript の基本機能を使う。相互依存のない複数タスクがある場合に速度面で有効です

[`examples/agent-patterns`](https://github.com/openai/openai-agents-js/tree/main/examples/agent-patterns) に多数の例があります。

## 関連ガイド

- 構成パターンとエージェント設定は [エージェント](/openai-agents-js/ja/guides/agents)
- `agent.asTool()` とマネージャースタイルのオーケストレーションは [ツール](/openai-agents-js/ja/guides/tools#agents-as-tools)
- 専門エージェント間の委任は [ハンドオフ](/openai-agents-js/ja/guides/handoffs)
- `Runner` と実行単位のオーケストレーション制御は [エージェントの実行](/openai-agents-js/ja/guides/running-agents)
- 最小のエンドツーエンドなハンドオフ例は [クイックスタート](/openai-agents-js/ja/guides/quickstart)
