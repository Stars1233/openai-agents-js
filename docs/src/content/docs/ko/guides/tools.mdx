---
title: 도구
description: Provide your agents with capabilities via hosted tools or custom function tools
---

import { Code } from '@astrojs/starlight/components';
import toolsFunctionExample from '../../../../../../examples/docs/tools/functionTools.ts?raw';
import toolsHostedToolsExample from '../../../../../../examples/docs/tools/hostedTools.ts?raw';
import localBuiltInToolsExample from '../../../../../../examples/docs/tools/localBuiltInTools.ts?raw';
import nonStrictSchemaTools from '../../../../../../examples/docs/tools/nonStrictSchemaTools.ts?raw';
import agentsAsToolsExample from '../../../../../../examples/docs/tools/agentsAsTools.ts?raw';
import agentsAsToolsStreamingExample from '../../../../../../examples/docs/tools/agentsAsToolsStreaming.ts?raw';
import mcpLocalServer from '../../../../../../examples/docs/tools/mcpLocalServer.ts?raw';
import codexToolExample from '../../../../../../examples/docs/tools/codexTool.ts?raw';
import codexRunContextThreadExample from '../../../../../../examples/docs/tools/codexRunContextThread.ts?raw';

도구를 사용하면 에이전트가 **작업을 수행**할 수 있습니다. 데이터를 가져오고, 외부 API 를 호출하고, 코드를 실행하고, 심지어 컴퓨터를 사용할 수도 있습니다. JavaScript/TypeScript SDK 는 여섯 가지 카테고리를 지원합니다:

1. **OpenAI 호스트하는 도구** – OpenAI 서버에서 모델과 함께 실행됩니다. _(웹 검색, 파일 검색, 코드 인터프리터, 이미지 생성)_
2. **내장 실행 도구** – SDK 가 제공하며 모델 외부에서 실행되는 도구입니다. _(컴퓨터 사용 및 apply_patch 는 로컬에서 실행되며, shell 은 로컬 또는 호스팅 컨테이너에서 실행 가능)_
3. **함수 도구** – JSON 스키마로 로컬 함수를 감싸 LLM 이 호출할 수 있게 합니다
4. **Agents as tools** – 전체 에이전트를 호출 가능한 도구로 노출합니다
5. **MCP 서버** – Model Context Protocol 서버(로컬 또는 원격)를 연결합니다
6. **실험적: Codex 도구** – Codex SDK 를 함수 도구로 감싸 워크스페이스 인식 작업을 실행합니다

---

## 도구 카테고리

이 가이드의 나머지 부분에서는 먼저 각 도구 카테고리를 다룬 뒤, 카테고리 전반에 걸친 도구 선택 및 프롬프팅 가이드를 요약합니다.

### 1. 호스티드 툴 (OpenAI Responses API)

`OpenAIResponsesModel` 을 사용할 때 다음 내장 도구를 추가할 수 있습니다:

| 도구             | 타입 문자열          | 목적                                |
| ---------------- | -------------------- | ----------------------------------- |
| 웹 검색          | `'web_search'`       | 인터넷 검색                         |
| 파일/검색 검색   | `'file_search'`      | OpenAI 에 호스팅된 벡터 스토어 조회 |
| Code Interpreter | `'code_interpreter'` | 샌드박스 환경에서 코드 실행         |
| 이미지 생성      | `'image_generation'` | 텍스트 기반 이미지 생성             |

<Code lang="typescript" code={toolsHostedToolsExample} title="Hosted tools" />

SDK 는 호스티드 툴 정의를 반환하는 헬퍼 함수를 제공합니다:

| 헬퍼 함수                       | 참고                                                                                                                                                                |
| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `webSearchTool(options?)`       | `searchContextSize`, `userLocation`, `filters.allowedDomains` 와 같은 JS 친화적 옵션                                                                                |
| `fileSearchTool(ids, options?)` | 첫 번째 인수로 하나 이상의 벡터 스토어 ID 를 받고, `maxNumResults`, `includeSearchResults`, `rankingOptions`, 필터 등의 옵션을 추가로 받음                          |
| `codeInterpreterTool(options?)` | `container` 를 제공하지 않으면 자동 관리 컨테이너를 기본값으로 사용                                                                                                 |
| `imageGenerationTool(options?)` | `model`, `size`, `quality`, `background`, `inputFidelity`, `inputImageMask`, `moderation`, `outputCompression`, `partialImages`, 출력 형식 등 이미지 생성 설정 지원 |

이 헬퍼들은 JavaScript/TypeScript 친화적 옵션 이름을 OpenAI Responses API 의 실제 도구 페이로드로 매핑합니다. 전체 도구 스키마와 ranking options, semantic filters 같은 고급 옵션은 OpenAI 공식 문서를 참고하세요.

---

### 2. 내장 실행 도구

이 도구들은 SDK 에 내장되어 있지만 실행은 모델 응답 자체 외부에서 이루어집니다:

- **컴퓨터 사용** – `Computer` 인터페이스를 구현해 `computerTool()` 에 전달합니다. 이 방식은 항상 사용자가 제공한 로컬 `Computer` 구현을 대상으로 실행됩니다
- **Shell** – 로컬 `Shell` 구현을 제공하거나 `shellTool({ environment })` 로 호스팅 컨테이너 환경을 구성할 수 있습니다
- **Apply patch** – `Editor` 인터페이스를 구현해 `applyPatchTool()` 에 전달합니다. 이 방식은 항상 사용자가 제공한 로컬 `Editor` 구현을 대상으로 실행됩니다

도구 호출은 여전히 모델이 요청하지만, 실제 작업은 애플리케이션 또는 구성된 실행 환경이 수행합니다.

<Code
  lang="typescript"
  code={localBuiltInToolsExample}
  title="Built-in execution tools"
/>

#### 컴퓨터 도구 세부 사항

`computerTool()` 은 다음 중 하나를 받습니다:

- 구체적인 `Computer` 인스턴스
- 실행마다 `Computer` 를 생성하는 초기화 함수
- 실행 범위 setup/teardown 이 필요할 때 `{ create, dispose }` 형태의 provider 객체

컴퓨터 작업을 사용자 검토를 위해 일시 정지해야 한다면 `needsApproval` 을 사용하고, 컴퓨터 작업 중 발생한 보류 중 안전성 검사를 승인 또는 거부하려면 `onSafetyCheck` 를 사용하세요.

#### Shell 도구 세부 사항

`shellTool()` 은 두 가지 모드를 제공합니다:

- 로컬 모드: `shell` 을 제공하고, 선택적으로 `environment: { type: 'local', skills }` 와 자동 승인 처리를 위한 `needsApproval`, `onApproval` 을 추가
- 호스티드 컨테이너 모드: `type: 'container_auto'` 또는 `type: 'container_reference'` 를 포함한 `environment` 제공

로컬 모드에서는 `environment.skills` 를 통해 `name`, `description`, 파일시스템 `path` 로 로컬 스킬을 마운트할 수 있습니다.

호스티드 컨테이너 모드에서는 `shellTool({ environment })` 를 다음 중 하나로 구성합니다:

- `type: 'container_auto'`: 실행용 관리형 컨테이너 생성
- `type: 'container_reference'`: `containerId` 로 기존 컨테이너 재사용

호스티드 `container_auto` 환경은 다음을 지원합니다:

- `domainSecrets` 를 포함한 allowlist 등의 `networkPolicy`
- 업로드 파일 마운트를 위한 `fileIds`
- 컨테이너 크기 조정을 위한 `memoryLimit`
- `skill_reference` 또는 인라인 zip 번들 형태의 `skills`

호스티드 shell 환경은 실행이 로컬 프로세스가 아닌 호스티드 컨테이너 환경에서 이루어지므로 `shell`, `needsApproval`, `onApproval` 을 받지 않습니다.

전체 사용 예시는 `examples/tools/local-shell.ts`, `examples/tools/container-shell-skill-ref.ts`, `examples/tools/container-shell-inline-skill.ts` 를 참고하세요.

#### Apply-patch 도구 세부 사항

`applyPatchTool()` 은 `shellTool()` 의 로컬 승인 흐름을 그대로 따릅니다. 파일 수정 전에 일시 정지하려면 `needsApproval` 을, 앱 수준 콜백으로 자동 승인/거부를 처리하려면 `onApproval` 을 사용하세요.

---

### 3. 함수 도구

`tool()` 헬퍼를 사용하면 **어떤** 함수든 도구로 만들 수 있습니다.

<Code
  lang="typescript"
  code={toolsFunctionExample}
  title="Function tool with Zod parameters"
/>

#### 옵션 참조

| 필드                   | 필수 여부 | 설명                                                                                                                                                                                                                               |
| ---------------------- | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `name`                 | 아니요    | 기본값은 함수 이름(예: `get_weather`)                                                                                                                                                                                              |
| `description`          | 예        | LLM 에 표시되는 명확하고 사람이 읽기 쉬운 설명                                                                                                                                                                                     |
| `parameters`           | 예        | Zod 스키마 또는 원문 JSON 스키마 객체. Zod parameters 는 자동으로 **strict** 모드를 활성화                                                                                                                                         |
| `strict`               | 아니요    | `true`(기본값)일 때 인수가 검증에 실패하면 SDK 가 모델 오류를 반환. 유사 매칭을 원하면 `false`                                                                                                                                     |
| `execute`              | 예        | `(args, context, details) => string \| unknown \| Promise<...>` – 비즈니스 로직. 문자열이 아닌 출력은 모델용으로 직렬화됨. `context` 는 선택적 `RunContext`, `details` 는 `toolCall`, `resumeState`, `signal` 등 메타데이터를 포함 |
| `errorFunction`        | 아니요    | 내부 오류를 사용자에게 보이는 문자열로 변환하는 커스텀 핸들러 `(context, error) => string`                                                                                                                                         |
| `timeoutMs`            | 아니요    | 호출당 타임아웃(밀리초). 0 보다 크고 `2147483647` 이하                                                                                                                                                                             |
| `timeoutBehavior`      | 아니요    | 타임아웃 모드: `error_as_result`(기본값)은 모델에 보이는 타임아웃 메시지 반환, `raise_exception` 은 `ToolTimeoutError` 발생                                                                                                        |
| `timeoutErrorFunction` | 아니요    | `timeoutBehavior` 가 `error_as_result` 일 때 타임아웃 출력용 커스텀 핸들러 `(context, timeoutError) => string`                                                                                                                     |
| `needsApproval`        | 아니요    | 실행 전 사람 승인 요구. [휴먼 인 더 루프 (HITL) 가이드](/openai-agents-js/ko/guides/human-in-the-loop) 참고                                                                                                                        |
| `isEnabled`            | 아니요    | 실행별 도구 노출을 조건부 제어. boolean 또는 predicate 허용                                                                                                                                                                        |
| `inputGuardrails`      | 아니요    | 도구 실행 전에 동작하는 가드레일. 거부 또는 예외 발생 가능. [가드레일](/openai-agents-js/ko/guides/guardrails#tool-guardrails) 참고                                                                                                |
| `outputGuardrails`     | 아니요    | 도구 실행 후 동작하는 가드레일. 거부 또는 예외 발생 가능. [가드레일](/openai-agents-js/ko/guides/guardrails#tool-guardrails) 참고                                                                                                  |

#### 함수 도구 타임아웃

각 함수 도구 호출 시간을 제한하려면 `timeoutMs` 를 사용하세요.

- `timeoutBehavior: 'error_as_result'`(기본값)은 모델에 `Tool '<name>' timed out after <timeoutMs>ms.` 를 반환합니다
- `timeoutBehavior: 'raise_exception'` 은 [`ToolTimeoutError`](/openai-agents-js/openai/agents-core/classes/tooltimeouterror) 를 발생시키며, [에이전트 실행 예외](/openai-agents-js/ko/guides/running-agents#exceptions)의 일부로 처리할 수 있습니다
- `timeoutErrorFunction` 은 `error_as_result` 모드에서 타임아웃 메시지를 사용자 정의할 수 있게 합니다
- 타임아웃이 발생하면 `details.signal` 이 중단되므로, 취소 신호를 처리하는 장시간 실행 도구를 즉시 멈출 수 있습니다

함수 도구를 직접 호출한다면 [`invokeFunctionTool`](/openai-agents-js/openai/agents/functions/invokefunctiontool) 을 사용해 일반 에이전트 실행과 동일한 타임아웃 동작을 적용하세요.

#### 비엄격 JSON-schema 도구

원문 JSON schema 사용 시 모델이 유효하지 않거나 부분적인 입력을 _추측_ 하도록 하려면 strict 모드를 비활성화할 수 있습니다:

<Code
  lang="typescript"
  code={nonStrictSchemaTools}
  title="Non-strict JSON schema tools"
/>

---

### 4. Agents as tools

대화를 완전히 핸드오프하지 않고 한 에이전트가 다른 에이전트를 _보조_ 하게 하고 싶을 때는 `agent.asTool()` 을 사용하세요:

<Code lang="typescript" code={agentsAsToolsExample} title="Agents as tools" />

내부적으로 SDK 는 다음을 수행합니다:

- 단일 `input` 매개변수를 갖는 함수 도구 생성
- 도구가 호출되면 해당 입력으로 하위 에이전트 실행
- 마지막 메시지 또는 `customOutputExtractor` 가 추출한 출력을 반환

에이전트를 도구로 실행하면 Agents SDK 는 기본 설정으로 runner 를 생성하고 함수 실행 내부에서 해당 에이전트를 실행합니다. `runConfig` 또는 `runOptions` 속성을 지정하려면 `asTool()` 메서드에 전달해 runner 동작을 사용자 지정할 수 있습니다.

또한 `asTool()` 옵션에서 `needsApproval` 과 `isEnabled` 를 설정해 휴먼‑인‑더‑루프 흐름 및 조건부 도구 가용성과 통합할 수 있습니다.

`agent.asTool()` 의 고급 구조화 입력 옵션:

- `inputBuilder`: 구조화된 도구 인수를 중첩 에이전트 입력 페이로드로 매핑
- `includeInputSchema`: 더 강한 스키마 인식 동작을 위해 중첩 실행에 입력 JSON schema 포함
- `resumeState`: 중첩 직렬화 `RunState` 재개 시 컨텍스트 조정 전략 제어. `'merge'`(기본값)는 라이브 승인/컨텍스트 상태를 직렬화 상태에 병합, `'replace'` 는 현재 실행 컨텍스트를 사용, `'preferSerialized'` 는 직렬화된 컨텍스트를 변경 없이 사용

#### 에이전트 도구의 스트리밍 이벤트

에이전트 도구는 중첩 실행의 모든 이벤트를 앱으로 스트리밍할 수 있습니다. 도구 구성 방식에 맞는 훅 스타일을 선택하세요:

<Code
  lang="typescript"
  code={agentsAsToolsStreamingExample}
  title="Streaming agent tools"
/>

- 이벤트 타입은 `RunStreamEvent['type']` 과 동일: `raw_model_stream_event`, `run_item_stream_event`, `agent_updated_stream_event`
- `onStream` 은 가장 단순한 “catch-all” 방식이며 도구를 인라인으로 선언할 때(`tools: [agent.asTool({ onStream })]`) 잘 맞습니다. 이벤트별 라우팅이 필요 없다면 이 방식을 사용하세요
- `on(eventName, handler)` 는 선택 구독(또는 `'*'`)을 제공하며, 더 세밀한 처리나 생성 후 리스너 연결이 필요할 때 적합합니다
- `onStream` 또는 하나 이상의 `on(...)` 핸들러를 제공하면 agent-as-tool 은 자동으로 스트리밍 모드로 실행되며, 없으면 비스트리밍 경로를 유지합니다
- 핸들러는 병렬로 호출되므로 느린 `onStream` 콜백이 `on(...)` 핸들러를 막지 않습니다(반대도 동일)
- `toolCallId` 는 도구가 모델 도구 호출로 실행된 경우 제공됩니다. 직접 `invoke()` 호출이나 provider 특성에 따라 생략될 수 있습니다

---

### 5. MCP 서버

[Model Context Protocol (MCP)](https://modelcontextprotocol.io/) 서버를 통해 도구를 노출하고 에이전트에 연결할 수 있습니다.
예를 들어 `MCPServerStdio` 를 사용해 stdio MCP 서버를 스폰하고 연결할 수 있습니다:

<Code lang="typescript" code={mcpLocalServer} title="Local MCP server" />

전체 예시는 [`filesystem-example.ts`](https://github.com/openai/openai-agents-js/tree/main/examples/mcp/filesystem-example.ts) 를 참고하세요. 또한 MCP 서버 도구 통합에 대한 종합 가이드는 [MCP 가이드](/openai-agents-js/ko/guides/mcp) 를 참고하세요.
여러 서버(또는 부분 실패)를 관리할 때는 `connectMcpServers` 와 [MCP 가이드](/openai-agents-js/ko/guides/mcp#managing-mcp-server-lifecycle)의 lifecycle 지침을 사용하세요.

---

### 6. 실험적: Codex 도구

`@openai/agents-extensions/experimental/codex` 는 `codexTool()` 을 제공합니다. 이 함수 도구는 모델의 도구 호출을 Codex SDK 로 라우팅하여 에이전트가 워크스페이스 범위 작업(shell, 파일 편집, MCP 도구)을 자율적으로 수행하게 합니다. 이 표면은 실험적이며 변경될 수 있습니다.

먼저 의존성을 설치하세요:

```bash
npm install @openai/agents-extensions @openai/codex-sdk
```

빠른 시작:

<Code
  lang="typescript"
  code={codexToolExample}
  title="Experimental Codex tool"
/>

알아둘 점:

- 인증: `CODEX_API_KEY`(권장) 또는 `OPENAI_API_KEY` 를 제공하거나 `codexOptions.apiKey` 전달
- 입력: strict 스키마 — `inputs` 에 최소 하나의 `{ type: 'text', text }` 또는 `{ type: 'local_image', path }` 가 있어야 함
- 안전성: `sandboxMode` 와 `workingDirectory` 를 함께 사용. 디렉터리가 Git 저장소가 아니면 `skipGitRepoCheck` 설정
- 스레딩: `useRunContextThreadId: true` 는 최신 thread id 를 `runContext.context` 에 읽고/저장하며, 앱 상태에서 턴 간 재사용에 유용
- Thread ID 우선순위: 도구 호출 `threadId`(스키마에 포함된 경우) > run-context thread id > `codexTool({ threadId })`
- Run context 키: `name: 'codex'` 일 때 기본값은 `codexThreadId`, `name: 'engineer'` 같은 경우 `codexThreadId_<suffix>` (`codex_engineer` 로 정규화 후)
- 변경 가능한 context 요구사항: `useRunContextThreadId` 활성화 시 `run(..., { context })` 에 변경 가능한 객체 또는 `Map` 전달
- 네이밍: 도구 이름은 `codex` 네임스페이스로 정규화됨(`engineer` → `codex_engineer`), 에이전트 내 중복 Codex 도구 이름은 거부됨
- 스트리밍: `onStream` 은 Codex 이벤트(추론, 명령 실행, MCP 도구 호출, 파일 변경, 웹 검색)를 반영하므로 진행 상황을 로깅/트레이싱 가능
- 출력: 도구 결과에는 `response`, `usage`, `threadId` 가 포함되며 Codex 토큰 사용량은 `RunContext` 에 기록됨
- 구조: `outputSchema` 는 descriptor, JSON schema 객체, Zod 객체를 사용할 수 있음. JSON 객체 스키마에서는 `additionalProperties` 가 `false` 여야 함

run-context 스레드 재사용 예시:

<Code
  lang="typescript"
  code={codexRunContextThreadExample}
  title="Codex run-context thread reuse"
/>

---

## 도구 전략 및 모범 사례

### 도구 사용 동작

모델이 도구를 언제, 어떻게 사용해야 하는지 제어하려면 [에이전트 가이드](/openai-agents-js/ko/guides/agents#forcing-tool-use)를 참고하세요 (`modelSettings.toolChoice`, `toolUseBehavior` 등).

---

### 모범 사례

- **짧고 명시적인 설명** – 도구가 _무엇을 하는지_ 와 _언제 사용해야 하는지_ 를 설명하세요
- **입력 검증** – 가능하면 엄격한 JSON 검증을 위해 Zod 스키마를 사용하세요
- **오류 핸들러에서 부작용 회피** – `errorFunction` 은 예외를 던지지 말고 도움이 되는 문자열을 반환해야 합니다
- **도구당 단일 책임** – 작고 조합 가능한 도구가 모델의 추론 성능을 높입니다

---

## 다음 단계

- [도구 사용 강제](/openai-agents-js/ko/guides/agents#forcing-tool-use)를 학습하세요
- 도구 입력/출력을 검증하도록 [가드레일](/openai-agents-js/ko/guides/guardrails)을 추가하세요
- [`tool()`](/openai-agents-js/openai/agents/functions/tool) 및 다양한 호스티드 툴 타입의 TypeDoc 참조를 살펴보세요
