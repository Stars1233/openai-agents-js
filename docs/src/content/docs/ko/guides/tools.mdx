---
title: 도구
description: Provide your agents with capabilities via hosted tools or custom function tools
---

import { Code } from '@astrojs/starlight/components';
import toolsFunctionExample from '../../../../../../examples/docs/tools/functionTools.ts?raw';
import toolsHostedToolsExample from '../../../../../../examples/docs/tools/hostedTools.ts?raw';
import localBuiltInToolsExample from '../../../../../../examples/docs/tools/localBuiltInTools.ts?raw';
import nonStrictSchemaTools from '../../../../../../examples/docs/tools/nonStrictSchemaTools.ts?raw';
import agentsAsToolsExample from '../../../../../../examples/docs/tools/agentsAsTools.ts?raw';
import agentsAsToolsStreamingExample from '../../../../../../examples/docs/tools/agentsAsToolsStreaming.ts?raw';
import mcpLocalServer from '../../../../../../examples/docs/tools/mcpLocalServer.ts?raw';
import codexToolExample from '../../../../../../examples/docs/tools/codexTool.ts?raw';
import codexRunContextThreadExample from '../../../../../../examples/docs/tools/codexRunContextThread.ts?raw';

도구는 에이전트가 **행동을 취하도록** 합니다. 데이터 가져오기, 외부 API 호출, 코드 실행, 심지어 컴퓨터 사용까지 가능합니다. JavaScript/TypeScript SDK는 다음 여섯 가지 카테고리를 지원합니다:

1. **Hosted OpenAI tools** – OpenAI 서버에서 모델과 함께 실행됩니다. _(web search, file search, code interpreter, image generation)_
2. **Local built-in tools** – 사용자의 환경에서 실행됩니다. _(computer use, shell, apply_patch)_
3. **Function tools** – 로컬 함수를 JSON 스키마로 감싸 LLM이 호출할 수 있게 합니다.
4. **Agents as tools** – 전체 에이전트를 호출 가능한 도구로 노출합니다.
5. **MCP servers** – Model Context Protocol 서버(로컬 또는 원격)를 연결합니다.
6. **Experimental: Codex tool** – Codex SDK를 함수 도구로 감싸 작업공간 인지 작업을 실행합니다.

---

## 도구 카테고리

이 가이드는 각 도구 카테고리를 먼저 다루고, 이후 공통적인 도구 선택 및 프롬프트 작성 가이드를 요약합니다.

### 1. 호스티드 도구 (OpenAI Responses API)

`OpenAIResponsesModel`을 사용할 때 다음 내장 도구를 추가할 수 있습니다:

| Tool                    | Type string          | Purpose                               |
| ----------------------- | -------------------- | ------------------------------------- |
| Web search              | `'web_search'`       | Internet search.                      |
| File / retrieval search | `'file_search'`      | Query vector stores hosted on OpenAI. |
| Code Interpreter        | `'code_interpreter'` | Run code in a sandboxed environment.  |
| Image generation        | `'image_generation'` | Generate images based on text.        |

<Code lang="typescript" code={toolsHostedToolsExample} title="Hosted tools" />

SDK는 다음과 같은 호스티드 도구 정의를 반환하는 헬퍼 함수를 제공합니다:

| Helper function                 | Notes                                                                                             |
| ------------------------------- | ------------------------------------------------------------------------------------------------- |
| `webSearchTool(options?)`       | `searchContextSize`, `userLocation`, `filters.allowedDomains` 같은 JS 친화적 옵션을 지원합니다.   |
| `fileSearchTool(ids, options?)` | 첫 번째 인자로 하나 이상의 벡터 스토어 ID를 받고, `maxNumResults` 및 필터 등의 옵션을 허용합니다. |
| `codeInterpreterTool(options?)` | `container`가 제공되지 않으면 자동 관리 컨테이너를 기본값으로 사용합니다.                         |
| `imageGenerationTool(options?)` | `size`, `quality`, `background`, 출력 포맷 등 이미지 생성 구성을 지원합니다.                      |

이 헬퍼들은 JavaScript/TypeScript 친화적 옵션 이름을 OpenAI Responses API의 하위 도구 페이로드로 매핑합니다. 전체 도구 스키마와 랭킹 옵션이나 시맨틱 필터 같은 고급 옵션은 OpenAI 공식 문서를 참고하세요.

---

### 2. 로컬 내장 도구

로컬 내장 도구는 사용자의 환경에서 실행되며 구현을 제공해야 합니다:

- **컴퓨터 사용** – `Computer` 인터페이스를 구현하고 `computerTool()`에 전달합니다.
- **Shell** – 로컬 `Shell` 구현을 제공하거나, 호스티드 컨테이너 환경을 구성합니다.
- **Apply patch** – `Editor` 인터페이스를 구현하고 `applyPatchTool()`에 전달합니다.

Computer 및 apply-patch 도구는 로컬에서 실행되며 OpenAI에서 호스트되지 **않습니다**. Shell 도구는 `shellTool()` 구성에 따라 로컬 또는 호스티드 컨테이너 환경에서 실행될 수 있습니다.
도구 호출은 여전히 모델의 응답에 의해 요청되지만, 해당 호출을 어떻게 실행할지는 애플리케이션이 제어합니다.

<Code
  lang="typescript"
  code={localBuiltInToolsExample}
  title="Local built-in tools"
/>

호스티드 쉘 환경의 경우, `shellTool({ environment })`를 다음 중 하나로 구성하세요:

- `type: 'container_auto'` 실행을 위해 관리형 컨테이너를 생성합니다(네트워크 정책, 메모리 제한, 스킬 지원).
- `type: 'container_reference'` 기존 컨테이너를 `containerId`로 재사용합니다.

엔드 투 엔드 사용법은 `examples/tools/container-shell-skill-ref.ts` 및 `examples/tools/container-shell-inline-skill.ts`를 참고하세요.

---

### 3. Function tools

`tool()` 헬퍼를 사용하면 **어떤** 함수든 도구로 전환할 수 있습니다.

<Code
  lang="typescript"
  code={toolsFunctionExample}
  title="Function tool with Zod parameters"
/>

#### 옵션 참조

| Field                  | Required | Description                                                                                                                                                                                                                                                |
| ---------------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `name`                 | No       | 함수 이름(예: `get_weather`)을 기본값으로 사용합니다.                                                                                                                                                                                                      |
| `description`          | Yes      | LLM에 표시되는 명확하고 사람이 읽을 수 있는 설명입니다.                                                                                                                                                                                                    |
| `parameters`           | Yes      | Zod 스키마 또는 원문 JSON 스키마 객체 중 하나입니다. Zod 매개변수를 사용하면 자동으로 **strict** 모드가 활성화됩니다.                                                                                                                                      |
| `strict`               | No       | `true`(기본값)일 때, 인자가 유효성 검사를 통과하지 못하면 SDK가 모델 오류를 반환합니다. 모호한 매칭을 원하면 `false`로 설정하세요.                                                                                                                         |
| `execute`              | Yes      | `(args, context, details) => string \| unknown \| Promise<...>` – 비즈니스 로직입니다. 문자열이 아닌 출력은 모델을 위해 직렬화됩니다. `context`는 선택적 `RunContext`이며, `details`에는 `toolCall`, `resumeState`, `signal` 같은 메타데이터가 포함됩니다. |
| `errorFunction`        | No       | 내부 오류를 사용자에게 표시할 문자열로 변환하는 커스텀 핸들러 `(context, error) => string`입니다.                                                                                                                                                          |
| `timeoutMs`            | No       | 호출당 타임아웃(밀리초)입니다. 0 초과, `2147483647` 이하이어야 합니다.                                                                                                                                                                                     |
| `timeoutBehavior`      | No       | 타임아웃 모드: 기본값 `error_as_result`는 모델에 타임아웃 메시지를 반환하고, `raise_exception`은 `ToolTimeoutError`를 던집니다.                                                                                                                            |
| `timeoutErrorFunction` | No       | `timeoutBehavior`가 `error_as_result`일 때 타임아웃 출력을 커스터마이징하는 핸들러 `(context, timeoutError) => string`입니다.                                                                                                                              |
| `needsApproval`        | No       | 실행 전에 사람의 승인을 요구합니다. 자세한 내용은 [휴먼 인 더 루프 (HITL)](/openai-agents-js/ko/guides/human-in-the-loop)을 참고하세요.                                                                                                                    |
| `isEnabled`            | No       | 실행별로 조건부로 도구를 노출합니다. 불리언 또는 프레디킷을 허용합니다.                                                                                                                                                                                    |
| `inputGuardrails`      | No       | 도구 실행 전에 동작하는 가드레일입니다. 거부하거나 예외를 던질 수 있습니다. [가드레일](/openai-agents-js/ko/guides/guardrails#tool-guardrails)을 참고하세요.                                                                                               |
| `outputGuardrails`     | No       | 도구 실행 후 동작하는 가드레일입니다. 거부하거나 예외를 던질 수 있습니다. [가드레일](/openai-agents-js/ko/guides/guardrails#tool-guardrails)을 참고하세요.                                                                                                 |

#### 함수 도구 타임아웃

`timeoutMs`를 사용해 각 함수 도구 호출 시간을 제한하세요.

- `timeoutBehavior: 'error_as_result'`(기본값)는 모델에 `Tool '<name>' timed out after <timeoutMs>ms.`를 반환합니다.
- `timeoutBehavior: 'raise_exception'`은 [`ToolTimeoutError`](/openai-agents-js/openai/agents-core/classes/tooltimeouterror)를 던지며, [실행 예외](/openai-agents-js/ko/guides/running-agents#exceptions)의 일부로 캐치할 수 있습니다.
- `timeoutErrorFunction`으로 `error_as_result` 모드의 타임아웃 텍스트를 커스터마이징할 수 있습니다.
- 타임아웃은 `details.signal`을 중단하므로, 장시간 실행되는 도구도 취소 신호를 수신하면 즉시 중단할 수 있습니다.

함수 도구를 직접 호출하는 경우, 일반 에이전트 실행과 동일한 타임아웃 동작을 적용하려면 [`invokeFunctionTool`](/openai-agents-js/openai/agents/functions/invokefunctiontool)을 사용하세요.

#### 비 엄격 JSON 스키마 도구

모델이 잘못되었거나 부분적인 입력을 추론해야 하는 경우, 원문 JSON 스키마 사용 시 strict 모드를 비활성화할 수 있습니다:

<Code
  lang="typescript"
  code={nonStrictSchemaTools}
  title="Non-strict JSON schema tools"
/>

---

### 4. Agents as tools

대화를 완전히 넘기지 않고 한 에이전트가 다른 에이전트를 *보조*하도록 하고 싶을 때 `agent.asTool()`을 사용하세요:

<Code lang="typescript" code={agentsAsToolsExample} title="Agents as tools" />

SDK는 내부적으로 다음을 수행합니다:

- 단일 `input` 매개변수를 가진 함수 도구를 생성합니다.
- 도구가 호출되면 하위 에이전트를 해당 입력으로 실행합니다.
- 마지막 메시지 또는 `customOutputExtractor`로 추출한 출력을 반환합니다.

에이전트를 도구로 실행하면, Agents SDK가 기본 설정으로 러너를 생성하고 함수 실행 내에서 에이전트를 실행합니다. `runConfig` 또는 `runOptions`의 속성을 제공하려면, 러너의 동작을 커스터마이징하기 위해 `asTool()` 메서드에 전달할 수 있습니다.

또한 `asTool()` 옵션을 통해 에이전트 도구에 `needsApproval`과 `isEnabled`를 설정하여 휴먼인더루프(HITL) 흐름 및 조건부 도구 가용성과 통합할 수 있습니다.

`agent.asTool()`의 고급 구조적 입력 옵션:

- `inputBuilder`: 구조화된 도구 인자를 중첩 에이전트 입력 페이로드로 매핑합니다.
- `includeInputSchema`: 보다 강력한 스키마 인지 동작을 위해 입력 JSON 스키마를 중첩 실행에 포함합니다.
- `resumeState`: 중첩된 직렬화 `RunState`를 재개할 때 컨텍스트 조정 전략을 제어합니다.

#### 에이전트 도구의 스트리밍 이벤트

에이전트 도구는 모든 중첩 실행 이벤트를 앱으로 스트리밍할 수 있습니다. 도구를 구성하는 방식에 맞는 훅 스타일을 선택하세요:

<Code
  lang="typescript"
  code={agentsAsToolsStreamingExample}
  title="Streaming agent tools"
/>

- 이벤트 타입은 `RunStreamEvent['type']`와 일치합니다: `raw_model_stream_event`, `run_item_stream_event`, `agent_updated_stream_event`
- `onStream`은 가장 간단한 “모든 이벤트 수신” 방식이며, 도구를 인라인으로 선언할 때 잘 동작합니다(`tools: [agent.asTool({ onStream })]`). 이벤트별 라우팅이 필요 없다면 이 방식을 사용하세요.
- `on(eventName, handler)`는 선택적으로(또는 `'*'`로) 구독할 수 있으며, 더 정교한 처리가 필요하거나 생성 후 리스너를 연결하고 싶을 때 적합합니다.
- `onStream` 또는 임의의 `on(...)` 핸들러를 제공하면 에이전트-도구는 자동으로 스트리밍 모드로 동작합니다. 그렇지 않으면 비스트리밍 경로를 유지합니다.
- 핸들러는 병렬로 호출되므로, 느린 `onStream` 콜백이 `on(...)` 핸들러를 블로킹하지 않습니다(그 반대도 마찬가지).
- `toolCallId`는 도구가 모델의 도구 호출을 통해 호출되었을 때 제공됩니다. 직접 `invoke()` 호출하거나 공급자 특이점에 따라 생략될 수 있습니다.

---

### 5. MCP servers

[Model Context Protocol (MCP)](https://modelcontextprotocol.io/) 서버를 통해 도구를 노출하고 에이전트에 연결할 수 있습니다.
예를 들어 `MCPServerStdio`를 사용해 stdio MCP 서버를 생성하고 연결할 수 있습니다:

<Code lang="typescript" code={mcpLocalServer} title="Local MCP server" />

완전한 예시는 [`filesystem-example.ts`](https://github.com/openai/openai-agents-js/tree/main/examples/mcp/filesystem-example.ts)를 참고하세요. 또한 MCP 서버 도구 통합에 대한 포괄적인 가이드를 찾고 있다면, 자세한 내용은 [모델 컨텍스트 프로토콜 (MCP)](/openai-agents-js/ko/guides/mcp)를 참고하세요.
여러 서버(또는 부분 실패)를 관리할 때는 `connectMcpServers`와 [모델 컨텍스트 프로토콜 (MCP)](/openai-agents-js/ko/guides/mcp#managing-mcp-server-lifecycle)의 라이프사이클 가이드를 사용하세요.

---

### 6. Experimental: Codex tool

`@openai/agents-extensions/experimental/codex`는 `codexTool()`을 제공합니다. 이 함수 도구는 모델의 도구 호출을 Codex SDK로 라우팅해 에이전트가 작업공간 범위의 작업(shell, 파일 편집, MCP 도구)을 자율적으로 수행할 수 있게 합니다. 이 표면은 실험적이며 변경될 수 있습니다.

먼저 의존성을 설치하세요:

```bash
npm install @openai/agents-extensions @openai/codex-sdk
```

빠른 시작:

<Code
  lang="typescript"
  code={codexToolExample}
  title="Experimental Codex tool"
/>

알아둘 점:

- 인증: `CODEX_API_KEY`(권장) 또는 `OPENAI_API_KEY`를 제공하거나, `codexOptions.apiKey`를 전달하세요.
- 입력: 엄격한 스키마 — `inputs`에는 최소 하나의 `{ type: 'text', text }` 또는 `{ type: 'local_image', path }`가 있어야 합니다.
- 안전: `sandboxMode`를 `workingDirectory`와 함께 사용하세요. 디렉토리가 Git 저장소가 아니면 `skipGitRepoCheck`를 설정하세요.
- 스레딩: `useRunContextThreadId: true`는 최신 스레드 ID를 `runContext.context`에 읽고 저장하며, 앱 상태에서 턴 간 재사용에 유용합니다.
- 스레드 ID 우선순위: 도구 호출의 `threadId`(스키마에 포함된 경우)가 우선하며, 그 다음 런 컨텍스트의 스레드 ID, 마지막으로 `codexTool({ threadId })`입니다.
- 실행 컨텍스트 키: `name: 'codex'`일 때 기본값은 `codexThreadId`이며, `name: 'engineer'` 같은 이름은 `codexThreadId_<suffix>`입니다(정규화 후 `codex_engineer`).
- 변경 가능한 컨텍스트 요구: `useRunContextThreadId`가 활성화된 경우, `run(..., { context })`에 변경 가능한 객체 또는 `Map`을 전달하세요.
- 네이밍: 도구 이름은 `codex` 네임스페이스로 정규화됩니다(`engineer`는 `codex_engineer`가 되며), 에이전트 내 중복 Codex 도구 이름은 거부됩니다.
- 스트리밍: `onStream`은 Codex 이벤트(추론, 명령 실행, MCP 도구 호출, 파일 변경, 웹 검색)를 반영하므로 로그 또는 트레이싱에 사용할 수 있습니다.
- 출력: 도구 결과에는 `response`, `usage`, `threadId`가 포함되며, Codex 토큰 사용량은 `RunContext`에 기록됩니다.
- 구조: `outputSchema`는 디스크립터, JSON 스키마 객체, 또는 Zod 객체가 될 수 있습니다. JSON 객체 스키마의 경우 `additionalProperties`는 `false`여야 합니다.

런 컨텍스트 스레드 재사용 예시:

<Code
  lang="typescript"
  code={codexRunContextThreadExample}
  title="Codex run-context thread reuse"
/>

---

## 도구 전략 및 모범 사례

### 도구 사용 동작

모델이 도구를 언제, 어떻게 사용해야 하는지 제어하려면 [에이전트](/openai-agents-js/ko/guides/agents#forcing-tool-use)를 참고하세요(`modelSettings.toolChoice`, `toolUseBehavior` 등).

---

### 모범 사례

- **짧고 명시적인 설명** – 도구가 _무엇을_ 하고 _언제 사용해야 하는지_ 설명하세요.
- **입력 검증** – 가능하면 Zod 스키마로 엄격한 JSON 검증을 수행하세요.
- **오류 핸들러에서 부작용 회피** – `errorFunction`은 예외를 던지지 말고 유용한 문자열을 반환해야 합니다.
- **도구당 단일 책임** – 작고 조합 가능한 도구가 더 나은 모델 추론으로 이어집니다.

---

## 다음 단계

- [도구 사용 강제](/openai-agents-js/ko/guides/agents#forcing-tool-use)에 대해 알아보세요.
- 도구 입력 또는 출력을 검증하기 위해 [가드레일](/openai-agents-js/ko/guides/guardrails)을 추가하세요.
- [`tool()`](/openai-agents-js/openai/agents/functions/tool) 및 다양한 호스티드 도구 타입에 대한 TypeDoc 레퍼런스를 살펴보세요.
