---
title: 人机协作
description: Add a human in the loop check for your agent executions
---

import { Aside, Code } from '@astrojs/starlight/components';
import humanInTheLoopExample from '../../../../../../examples/docs/human-in-the-loop/index.ts?raw';
import toolApprovalDefinition from '../../../../../../examples/docs/human-in-the-loop/toolApprovalDefinition.ts?raw';

本指南演示如何使用 SDK 中的内置人工干预支持，根据人工介入来暂停和恢复智能体运行。

当前的主要用例是对敏感工具执行请求审批。

## 审批请求

你可以通过将 `needsApproval` 选项设置为 `true`，或设置为返回布尔值的异步函数，来定义一个需要审批的工具。

<Code
  lang="typescript"
  code={toolApprovalDefinition}
  title="工具审批定义"
  meta={`{10}`}
/>

### 流程

1. 当智能体决定调用一个（或多个）工具时，会通过评估 `needsApproval` 来检查该工具是否需要审批。
2. 如果需要审批，智能体会检查审批是否已授予或被拒绝。
   - 如果尚未批准或拒绝，该工具会向智能体返回一条静态消息，说明无法执行该工具调用。
   - 如果缺少批准/拒绝，将触发工具审批请求。
3. 智能体会收集所有工具审批请求并中断执行。
4. 如果发生任何中断，[执行结果](/openai-agents-js/zh/guides/results) 中将包含一个描述待处理步骤的 `interruptions` 数组。当某个工具调用需要确认时，会出现一个 `type: "tool_approval_item"` 的 ToolApprovalItem。
5. 你可以调用 `result.state.approve(interruption)` 或 `result.state.reject(interruption)` 来批准或拒绝该工具调用。如果希望在本次运行的剩余时间里保持同一工具始终被批准或拒绝，请传入 `{ alwaysApprove: true }` 或 `{ alwaysReject: true }`。
6. 处理完所有中断后，你可以通过将 `result.state` 传回 `runner.run(agent, state)` 来恢复执行，其中 `agent` 是触发整体运行的原始智能体。
7. 流程将从第 1 步重新开始。

## 示例

下面是一个更完整的人工干预流程示例：它会在终端中提示审批，并将状态暂存到文件中。

<Code lang="typescript" code={humanInTheLoopExample} title="人工干预" />

参见[完整示例脚本](https://github.com/openai/openai-agents-js/tree/main/examples/agent-patterns/human-in-the-loop.ts)以获取可运行的端到端版本。

## 处理较长审批时间

人工干预流程被设计为可在较长时间内可中断，而无需让你的服务器持续运行。如果你需要先结束请求，稍后再继续，可以序列化状态并在之后恢复。

你可以使用 `result.state.toString()`（或 `JSON.stringify(result.state)`）来序列化状态，稍后通过将序列化后的状态传入 `RunState.fromString(agent, serializedState)` 来恢复，其中 `agent` 是触发整体运行的智能体实例。

如果在恢复的过程中需要注入一个新的上下文对象，请改用 `RunState.fromStringWithContext(agent, serializedState, context, { contextStrategy })`。

- `contextStrategy: 'merge'`（默认）会保留已序列化的审批状态，并将其合并到提供的 `RunContext` 中。
- `contextStrategy: 'replace'` 会使用提供的 `RunContext` 原样重建运行。

默认情况下，追踪 API 密钥会从序列化状态中省略，以避免意外持久化机密。只有在你确实需要随状态一起迁移追踪凭据时，才传入 `result.state.toString({ includeTracingApiKey: true })`。

这样你就可以将序列化的状态存储在数据库中，或与请求一并存储。

### 待处理任务的版本管理

<Aside>
  这主要适用于在对智能体进行变更的同时，打算长时间存储序列化状态的情况。
</Aside>

如果你的审批请求需要较长时间，并且你打算以有意义的方式对智能体定义进行版本化，或提升你的 Agents SDK 版本，我们目前建议你通过使用包别名并行安装两个版本的 Agents SDK，来实现你自己的分支逻辑。

在实践中，这意味着为你的代码分配一个版本号，并将其与序列化状态一同存储，同时在反序列化时引导到你代码的正确版本。
