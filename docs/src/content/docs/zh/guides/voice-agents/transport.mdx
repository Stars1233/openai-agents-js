---
title: 传输机制
description: Learn about the different transport layers that can be used with Realtime Agents.
---

import { Steps } from '@astrojs/starlight/components';
import { Code } from '@astrojs/starlight/components';

import createAgentExample from '../../../../../../../examples/docs/voice-agents/createAgent.ts?raw';
import multiAgentsExample from '../../../../../../../examples/docs/voice-agents/multiAgents.ts?raw';
import createSessionExample from '../../../../../../../examples/docs/voice-agents/createSession.ts?raw';
import configureSessionExample from '../../../../../../../examples/docs/voice-agents/configureSession.ts?raw';
import handleAudioExample from '../../../../../../../examples/docs/voice-agents/handleAudio.ts?raw';
import defineToolExample from '../../../../../../../examples/docs/voice-agents/defineTool.ts?raw';
import toolApprovalEventExample from '../../../../../../../examples/docs/voice-agents/toolApprovalEvent.ts?raw';
import guardrailsExample from '../../../../../../../examples/docs/voice-agents/guardrails.ts?raw';
import guardrailSettingsExample from '../../../../../../../examples/docs/voice-agents/guardrailSettings.ts?raw';
import audioInterruptedExample from '../../../../../../../examples/docs/voice-agents/audioInterrupted.ts?raw';
import sessionInterruptExample from '../../../../../../../examples/docs/voice-agents/sessionInterrupt.ts?raw';
import sessionHistoryExample from '../../../../../../../examples/docs/voice-agents/sessionHistory.ts?raw';
import historyUpdatedExample from '../../../../../../../examples/docs/voice-agents/historyUpdated.ts?raw';
import updateHistoryExample from '../../../../../../../examples/docs/voice-agents/updateHistory.ts?raw';
import customWebRTCTransportExample from '../../../../../../../examples/docs/voice-agents/customWebRTCTransport.ts?raw';
import websocketSessionExample from '../../../../../../../examples/docs/voice-agents/websocketSession.ts?raw';
import sipTransportExample from '../../../../../../../examples/docs/voice-agents/sipTransport.ts?raw';
import transportEventsExample from '../../../../../../../examples/docs/voice-agents/transportEvents.ts?raw';
import thinClientExample from '../../../../../../../examples/docs/voice-agents/thinClient.ts?raw';
import cloudflareTransportExample from '../../../../../../../examples/docs/extensions/cloudflare-basic.ts?raw';

## 默认传输层

### 通过 WebRTC 连接

默认传输层使用 WebRTC。音频会从麦克风采集并自动回放。

若要使用自有的媒体流或音频元素，在创建会话时传入一个 `OpenAIRealtimeWebRTC` 实例。

<Code lang="typescript" code={customWebRTCTransportExample} />

对于更底层的自定义，`OpenAIRealtimeWebRTC` 也接受 `changePeerConnection`，它允许你在生成 offer 之前检查或替换新创建的 `RTCPeerConnection`。

### 通过 WebSocket 连接

在创建会话时传入 `transport: 'websocket'` 或 `OpenAIRealtimeWebSocket` 的实例，以使用 WebSocket 连接替代 WebRTC。这非常适合服务器端场景，例如使用 Twilio 构建电话智能体。

<Code lang="typescript" code={websocketSessionExample} />

使用任意录制/回放库来处理原始 PCM16 音频字节。

对于高级集成，`OpenAIRealtimeWebSocket` 接受 `createWebSocket()`，以便你提供自定义的 socket 实现；当该自定义连接器负责将 socket 切换到已连接状态时，可使用 `skipOpenEventListeners`。`@openai/agents-extensions` 中的 Cloudflare 传输即基于这些钩子实现。

### 通过 SIP 连接

使用 `OpenAIRealtimeSIP` 传输将来自 Twilio 等提供商的 SIP 呼叫进行桥接。该传输会将 Realtime 会话与电话提供商发出的 SIP 事件保持同步。

1. 使用 `OpenAIRealtimeSIP.buildInitialConfig()` 生成初始会话配置以接受来电。这可确保 SIP 邀请与 Realtime 会话共享相同的默认值。
2. 绑定一个使用 `OpenAIRealtimeSIP` 传输的 `RealtimeSession`，并使用提供商 webhook 下发的 `callId` 进行连接。
3. 监听会话事件以驱动通话分析、转写或升级逻辑。

<Code lang="typescript" code={sipTransportExample} />

#### Cloudflare Workers（workerd）注意事项

Cloudflare Workers 及其他 workerd 运行时无法使用全局 `WebSocket` 构造函数发起出站 WebSocket。请使用扩展包中的 Cloudflare 传输，它会在内部通过 `fetch()` 完成升级。

<Code lang="typescript" code={cloudflareTransportExample} />

### 构建自定义传输机制

如果你想使用不同的语音到语音 API，或拥有自定义的传输机制，可以通过实现 `RealtimeTransportLayer` 接口并触发 `RealtimeTransportEventTypes` 事件来创建你自己的传输层。

## 更直接地与 Realtime API 交互

如果你想使用 OpenAI Realtime API，同时对 Realtime API 拥有更直接的访问方式，有两种选择：

### 选项 1 - 访问传输层

如果你仍希望受益于 `RealtimeSession` 的全部能力，可以通过 `session.transport` 访问你的传输层。

传输层会在 `*` 事件下发出其接收到的每个事件，你也可以使用 `sendEvent()` 方法发送原始事件。

<Code lang="typescript" code={transportEventsExample} />

### 选项 2 — 仅使用传输层

如果你不需要自动工具执行、护栏等功能，也可以仅使用传输层作为一个“轻量”客户端，它只负责连接管理和中断处理。

<Code lang="typescript" code={thinClientExample} />
