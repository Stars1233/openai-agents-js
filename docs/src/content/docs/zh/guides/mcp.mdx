---
title: MCP 集成
description: Learn how to utilize MCP servers as tools
---

import { Code } from '@astrojs/starlight/components';
import hostedAgentExample from '../../../../../../examples/docs/mcp/hostedAgent.ts?raw';
import hostedExample from '../../../../../../examples/docs/mcp/hosted.ts?raw';
import hostedStreamExample from '../../../../../../examples/docs/mcp/hostedStream.ts?raw';
import hostedHITLExample from '../../../../../../examples/docs/mcp/hostedHITL.ts?raw';
import hostedConnectorExample from '../../../../../../examples/docs/mcp/hostedConnector.ts?raw';
import streamableHttpExample from '../../../../../../examples/docs/mcp/streamableHttp.ts?raw';
import stdioExample from '../../../../../../examples/docs/mcp/stdio.ts?raw';
import toolFilterExample from '../../../../../../examples/docs/mcp/tool-filter.ts?raw';
import mcpServersExample from '../../../../../../examples/docs/mcp/mcpServers.ts?raw';

[**Model Context Protocol (MCP)**](https://modelcontextprotocol.io) 是一种开放协议，用于标准化应用如何向 LLM 提供工具和上下文。摘自 MCP 文档：

> MCP 是一种开放协议，用于标准化应用如何向 LLM 提供上下文。可以把 MCP 想象成 AI 应用的 USB-C 接口。正如 USB-C 提供了将设备连接到各类外设和配件的标准方式，MCP 也提供了将 AI 模型连接到不同数据源和工具的标准方式。

此 SDK 支持三种 MCP 服务器类型：

1. **远程 MCP 服务器工具**——由 [OpenAI Responses API](https://platform.openai.com/docs/guides/tools-remote-mcp) 作为工具使用的远程 MCP 服务器
2. **Streamable HTTP MCP 服务器**——实现了 [Streamable HTTP transport](https://modelcontextprotocol.io/docs/concepts/transports#streamable-http) 的本地或远程服务器
3. **Stdio MCP 服务器**——通过标准输入/输出访问的服务器（最简单的选项）

> 注意：SDK 还包含用于旧版 Server-Sent Events 传输的 `MCPServerSSE`，但 MCP 项目已弃用 SSE。新集成请优先使用 Streamable HTTP 或 stdio。

请根据用例选择服务器类型：

| 您的需求                                                     | 推荐选项               |
| ------------------------------------------------------------ | ---------------------- |
| 调用可公开访问的远程服务器，并使用默认 OpenAI responses 模型 | **1. 远程 MCP 工具**   |
| 使用可公开访问的远程服务器，但在本地触发工具调用             | **2. Streamable HTTP** |
| 使用本地运行的 Streamable HTTP 服务器                        | **2. Streamable HTTP** |
| 使用任意 Streamable HTTP 服务器与非 OpenAI-Responses 模型    | **2. Streamable HTTP** |
| 使用仅支持标准输入/输出协议的本地 MCP 服务器                 | **3. Stdio**           |

## 1. 远程 MCP 服务器工具

远程工具会将完整的往返流程交给模型。您的代码不再直接调用 MCP 服务器，而是由 OpenAI Responses API 调用远程工具端点，并将结果流式返回给模型。

下面是使用远程 MCP 工具的最简单示例。您可以将远程 MCP 服务器的标签和 URL 传给 `hostedMcpTool` 工具函数，它有助于创建远程 MCP 服务器工具。

<Code lang="typescript" code={hostedAgentExample} title="hostedAgent.ts" />

然后，您可以通过 `run` 函数（或自定义 `Runner` 实例的 `run` 方法）运行智能体：

<Code lang="typescript" code={hostedExample} title="使用远程 MCP 工具运行" />

要流式接收增量 MCP 结果，请在运行 `Agent` 时传入 `stream: true`：

<Code
  lang="typescript"
  code={hostedStreamExample}
  title="使用远程 MCP 工具运行（流式传输）"
/>

### 可选审批流程

对于敏感操作，您可以要求人工审批单个工具调用。可传入 `requireApproval: 'always'`，或传入将工具名映射到 `'never'`/`'always'` 的细粒度对象。

如果您可以通过编程方式判断工具调用是否安全，可以使用 [`onApproval` 回调](https://github.com/openai/openai-agents-js/blob/main/examples/mcp/hosted-mcp-on-approval.ts)来批准或拒绝工具调用。如果您需要人工审批，也可以使用与本地函数工具相同的 [human-in-the-loop (HITL) approach](/openai-agents-js/zh/guides/human-in-the-loop/)，即使用 `interruptions`。

<Code
  lang="typescript"
  code={hostedHITLExample}
  title="远程 MCP 工具中的人工干预"
/>

### 远程 MCP 选项参考

`hostedMcpTool(...)` 同时支持 MCP 服务器 URL 和 connector 支持的服务器：

| 选项              | 类型                            | 说明                                                                           |
| ----------------- | ------------------------------- | ------------------------------------------------------------------------------ |
| `serverLabel`     | `string`                        | 必填标签，用于在事件和追踪中标识远程 MCP 服务器。                              |
| `serverUrl`       | `string`                        | 远程 MCP 服务器 URL（常规远程 MCP 服务器使用此项）。                           |
| `connectorId`     | `string`                        | OpenAI connector id（对 connector 支持的远程服务器，用此项替代 `serverUrl`）。 |
| `authorization`   | `string`                        | 可选的授权令牌，会发送到远程 MCP 后端。                                        |
| `headers`         | `Record<string, string>`        | 可选的额外请求头。                                                             |
| `allowedTools`    | `string[] \| object`            | 暴露给模型的工具名白名单。可传 `string[]` 或 `{ toolNames?: string[] }`。      |
| `requireApproval` | `'never' \| 'always' \| object` | 远程 MCP 工具调用的审批策略。按工具覆盖请使用对象形式。默认值为 `'never'`。    |
| `onApproval`      | Approval callback               | 当 `requireApproval` 需要审批处理时，用于程序化批准/拒绝的可选回调。           |

`requireApproval` 对象形式：

```ts
{
  always?: { toolNames: string[] };
  never?: { toolNames: string[] };
}
```

`onApproval` 签名：

```ts
async function onApproval(
  context,
  item,
): Promise<{
  approve: boolean;
  reason?: string;
}> {}
```

### Connector 支持的远程服务器

远程 MCP 也支持 OpenAI connectors。您无需提供 `serverUrl`，改为传入 connector 的 `connectorId` 和 `authorization` 令牌。随后 Responses API 会处理认证，并通过远程 MCP 接口暴露该 connector 的工具。

<Code
  lang="typescript"
  code={hostedConnectorExample}
  title="Connector 支持的远程 MCP 工具"
/>

在此示例中，`GOOGLE_CALENDAR_AUTHORIZATION` 环境变量保存了从 Google OAuth Playground 获取的 OAuth 令牌，该令牌用于授权 connector 支持的服务器调用 Calendar API。可运行的示例（也演示了流式传输）见 [`examples/connectors`](https://github.com/openai/openai-agents-js/tree/main/examples/connectors)。

完整可运行示例（远程工具/Streamable HTTP/stdio + 流式传输、HITL、onApproval）位于我们 GitHub 仓库中的 [examples/mcp](https://github.com/openai/openai-agents-js/tree/main/examples/mcp)。

## 2. Streamable HTTP MCP 服务器

当您的智能体直接与 Streamable HTTP MCP 服务器（本地或远程）通信时，可用服务器 `url`、`name` 以及可选设置来实例化 `MCPServerStreamableHttp`：

<Code
  lang="typescript"
  code={streamableHttpExample}
  title="使用 Streamable HTTP MCP 服务器运行"
/>

构造函数选项：

| 选项                          | 类型                                           | 说明                                        |
| ----------------------------- | ---------------------------------------------- | ------------------------------------------- |
| `url`                         | `string`                                       | Streamable HTTP 服务器 URL。                |
| `name`                        | `string`                                       | 服务器的可选标签。                          |
| `cacheToolsList`              | `boolean`                                      | 缓存工具列表以降低延迟。                    |
| `clientSessionTimeoutSeconds` | `number`                                       | MCP 客户端会话超时时间。                    |
| `toolFilter`                  | `MCPToolFilterCallable \| MCPToolFilterStatic` | 过滤可用工具。                              |
| `toolMetaResolver`            | `MCPToolMetaResolver`                          | 为每次调用注入 MCP `_meta` 请求字段。       |
| `errorFunction`               | `MCPToolErrorFunction \| null`                 | 将 MCP 调用失败映射为模型可见文本。         |
| `timeout`                     | `number`                                       | 单次请求超时（毫秒）。                      |
| `logger`                      | `Logger`                                       | 自定义日志记录器。                          |
| `authProvider`                | `OAuthClientProvider`                          | 来自 MCP TypeScript SDK 的 OAuth provider。 |
| `requestInit`                 | `RequestInit`                                  | 请求的 fetch 初始化选项。                   |
| `fetch`                       | `FetchLike`                                    | 自定义 fetch 实现。                         |
| `reconnectionOptions`         | `StreamableHTTPReconnectionOptions`            | 重连调优选项。                              |
| `sessionId`                   | `string`                                       | MCP 连接的显式会话 id。                     |

构造函数还接受其他 MCP TypeScript-SDK 选项，例如 `authProvider`、`requestInit`、`fetch`、`reconnectionOptions` 和 `sessionId`。详情请参阅 [MCP TypeScript SDK repository](https://github.com/modelcontextprotocol/typescript-sdk) 及其文档。

## 3. Stdio MCP 服务器

对于仅暴露标准输入/输出的服务器，可使用 `fullCommand` 实例化 `MCPServerStdio`：

<Code lang="typescript" code={stdioExample} title="使用 Stdio MCP 服务器运行" />

构造函数选项：

| 选项                          | 类型                                           | 说明                                          |
| ----------------------------- | ---------------------------------------------- | --------------------------------------------- |
| `command` / `args`            | `string` / `string[]`                          | stdio 服务器的命令和参数。                    |
| `fullCommand`                 | `string`                                       | `command` + `args` 的完整命令字符串替代方案。 |
| `env`                         | `Record<string, string>`                       | 服务器进程的环境变量。                        |
| `cwd`                         | `string`                                       | 服务器进程的工作目录。                        |
| `cacheToolsList`              | `boolean`                                      | 缓存工具列表以降低延迟。                      |
| `clientSessionTimeoutSeconds` | `number`                                       | MCP 客户端会话超时时间。                      |
| `name`                        | `string`                                       | 服务器的可选标签。                            |
| `encoding`                    | `string`                                       | stdio 流的编码。                              |
| `encodingErrorHandler`        | `'strict' \| 'ignore' \| 'replace'`            | 编码错误处理策略。                            |
| `toolFilter`                  | `MCPToolFilterCallable \| MCPToolFilterStatic` | 过滤可用工具。                                |
| `toolMetaResolver`            | `MCPToolMetaResolver`                          | 为每次调用注入 MCP `_meta` 请求字段。         |
| `errorFunction`               | `MCPToolErrorFunction \| null`                 | 将 MCP 调用失败映射为模型可见文本。           |
| `timeout`                     | `number`                                       | 单次请求超时（毫秒）。                        |
| `logger`                      | `Logger`                                       | 自定义日志记录器。                            |

## MCP 服务器生命周期管理

当您使用多个 MCP 服务器时，可以使用 `connectMcpServers` 统一连接、跟踪失败并集中关闭。
该辅助函数会返回一个 `MCPServers` 实例，包含 `active`、`failed` 和 `errors` 集合，因此您可以只将健康服务器传给智能体。

<Code lang="typescript" code={mcpServersExample} title="管理多个 MCP 服务器" />

使用场景：

- **同时使用多个服务器**：并行连接全部服务器，并将 `mcpServers.active` 用于智能体。
- **部分失败处理**：检查 `failed` + `errors`，并决定继续还是重试。
- **重试失败服务器**：调用 `mcpServers.reconnect()`（默认仅重试失败服务器）。

如果您希望严格的“全有或全无”连接策略，或需要不同超时设置，请使用 `connectMcpServers(servers, options)` 并按环境调优选项。

`connectMcpServers` 选项：

| 选项                 | 类型             | 默认值  | 说明                                                  |
| -------------------- | ---------------- | ------- | ----------------------------------------------------- |
| `connectTimeoutMs`   | `number \| null` | `10000` | 每个服务器 `connect()` 的超时时间。传 `null` 可禁用。 |
| `closeTimeoutMs`     | `number \| null` | `10000` | 每个服务器 `close()` 的超时时间。传 `null` 可禁用。   |
| `dropFailed`         | `boolean`        | `true`  | 将失败服务器从 `active` 中排除。                      |
| `strict`             | `boolean`        | `false` | 任一服务器连接失败即抛出错误。                        |
| `suppressAbortError` | `boolean`        | `true`  | 忽略类似 abort 的错误，同时仍跟踪失败服务器。         |
| `connectInParallel`  | `boolean`        | `false` | 并发连接所有服务器，而不是顺序连接。                  |

`mcpServers.reconnect(options)` 支持：

| 选项         | 类型      | 默认值 | 说明                                                    |
| ------------ | --------- | ------ | ------------------------------------------------------- |
| `failedOnly` | `boolean` | `true` | 仅重试失败服务器（`true`）或重连所有服务器（`false`）。 |

### 异步释放（可选）

如果您的运行时支持 `Symbol.asyncDispose`，`MCPServers` 也支持 `await using` 模式。
在 TypeScript 中，请在 `tsconfig.json` 启用 `esnext.disposable`：

```json
{
  "compilerOptions": {
    "lib": ["ES2018", "DOM", "esnext.disposable"]
  }
}
```

然后可以这样写：

```ts
await using mcpServers = await connectMcpServers(servers);
```

## 其他须知

对于 **Streamable HTTP** 和 **Stdio** 服务器，每次运行 `Agent` 时都可能调用 `list_tools()` 以发现可用工具。由于这次往返会增加延迟（尤其是远程服务器），您可以在 `MCPServerStdio` 或 `MCPServerStreamableHttp` 中传入 `cacheToolsList: true`，将结果缓存到内存中。

仅在您确信工具列表不会变化时启用此选项。后续若需使缓存失效，请在服务器实例上调用 `invalidateToolsCache()`。
如果您使用 `getAllMcpTools(...)` 的共享 MCP 工具缓存，也可通过服务器名称调用 `invalidateServerToolsCache(serverName)` 进行失效。

对于高级场景，`getAllMcpTools({ generateMCPToolCacheKey })` 允许您自定义缓存分区（例如按服务器 + 智能体 + 运行上下文）。

### 工具过滤

您可以通过 `createMCPToolStaticFilter` 传入静态过滤器，或传入自定义函数，以限制每个服务器暴露的工具。以下是同时展示两种方式的示例：

<Code lang="typescript" code={toolFilterExample} title="工具过滤" />

## 延伸阅读

- [Model Context Protocol](https://modelcontextprotocol.io/)——官方规范。
- [examples/mcp](https://github.com/openai/openai-agents-js/tree/main/examples/mcp)——上文引用的可运行
  演示。
