---
title: 会话
description: Persist multi-turn conversation history so agents can resume context across runs.
---

import { Code } from '@astrojs/starlight/components';
import sessionsQuickstart from '../../../../../../examples/docs/sessions/basicSession.ts?raw';
import manageHistory from '../../../../../../examples/docs/sessions/manageHistory.ts?raw';
import customSession from '../../../../../../examples/docs/sessions/customSession.ts?raw';
import sessionInputCallback from '../../../../../../examples/docs/sessions/sessionInputCallback.ts?raw';
import responsesCompactionSession from '../../../../../../examples/docs/sessions/responsesCompactionSession.ts?raw';
import manualCompactionSession from '../../../../../../examples/docs/sessions/responsesCompactionManualSession.ts?raw';
import memorySessionExample from '../../../../../../examples/docs/sessions/memorySession.ts?raw';
import resumableRunExample from '../../../../../../examples/docs/sessions/resumableRun.ts?raw';

会话为 Agents SDK 提供了**持久化记忆层**。向 `Runner.run` 传入任何实现了 `Session` 接口的对象，SDK 会处理其余工作。当存在会话时，runner 会自动：

1. 获取先前存储的对话条目，并将其前置到下一轮中。
2. 每次运行完成后，持久化新的用户输入和助手输出。
3. 在后续轮次中持续使用该会话，无论你是用新的用户文本调用 runner，还是从中断的 `RunState` 恢复。

这样就无需手动调用 `toInputList()`，也不必在轮次之间自行拼接历史。TypeScript SDK 内置了两种实现：用于 Conversations API 的 `OpenAIConversationsSession`，以及面向本地开发的 `MemorySession`。由于它们共享 `Session` 接口，你也可以接入自己的存储后端。若想获取 Conversations API 之外的灵感，可查看 `examples/memory/` 下的示例会话后端（Prisma、文件后端等）。当你使用 OpenAI Responses 模型时，可用 `OpenAIResponsesCompactionSession` 包装任意会话，通过 [`responses.compact`](https://platform.openai.com/docs/api-reference/responses/compact) 自动压缩已存储的对话历史。

> 提示：要运行本页的 `OpenAIConversationsSession` 示例，请设置 `OPENAI_API_KEY` 环境变量（或在构造会话时提供 `apiKey`），以便 SDK 调用 Conversations API。

当你希望由 SDK 管理客户端侧记忆时，请使用会话。如果你已经在使用
OpenAI 服务器托管状态（通过 `conversationId` 或 `previousResponseId`），通常不需要再为同一段对话历史额外使用会话。

---

## 入门

### 快速开始

使用 `OpenAIConversationsSession` 与 [Conversations API](https://platform.openai.com/docs/api-reference/conversations) 同步记忆，或替换为任意其他 `Session` 实现。

<Code
  lang="typescript"
  code={sessionsQuickstart}
  title="Use the Conversations API as session memory"
/>

复用同一个会话实例可确保智能体在每一轮前都能获取完整对话历史，并自动持久化新条目。切换到其他 `Session` 实现时，无需改动其他代码。

对于本地演示、测试或进程内聊天状态，`MemorySession` 提供了相同接口，
且无需与 OpenAI 通信：

<Code
  lang="typescript"
  code={memorySessionExample}
  title="Use MemorySession for local state"
/>

`OpenAIConversationsSession` 构造选项：

| 选项             | 类型     | 说明                                      |
| ---------------- | -------- | ----------------------------------------- |
| `conversationId` | `string` | 复用现有会话，而不是延迟创建新会话。      |
| `client`         | `OpenAI` | 传入预配置的 OpenAI 客户端。              |
| `apiKey`         | `string` | 创建内部 OpenAI 客户端时使用的 API 密钥。 |
| `baseURL`        | `string` | OpenAI 兼容端点的基础 URL。               |
| `organization`   | `string` | 请求使用的 OpenAI 组织 ID。               |
| `project`        | `string` | 请求使用的 OpenAI 项目 ID。               |

`MemorySession` 构造选项：

| 选项           | 类型               | 说明                                       |
| -------------- | ------------------ | ------------------------------------------ |
| `sessionId`    | `string`           | 用于日志或测试的稳定标识符。默认自动生成。 |
| `initialItems` | `AgentInputItem[]` | 用已有历史初始化会话。                     |
| `logger`       | `Logger`           | 覆盖用于调试输出的 logger。                |

`MemorySession` 将所有内容存储在本地进程内存中，因此进程退出后会重置。

如果你需要在构造会话前预先创建对话 ID，请使用
`startOpenAIConversationsSession(client?)`，并将返回的 ID 作为 `conversationId` 传入。

---

## 会话核心行为

### runner 使用会话的方式

- **每次运行前**，会获取会话历史，与本轮新输入合并后传给你的智能体。
- **非流式运行后**，通过一次 `session.addItems()` 同时持久化原始用户输入和该轮模型输出。
- **流式运行时**，会先写入用户输入，待该轮完成后再追加流式输出。
- **从 `RunResult.state` 恢复时**（如审批或其他中断），请继续传入同一个 `session`。恢复轮次会直接加入记忆，无需重新准备输入。

---

### 历史查看与编辑

会话提供简洁的 CRUD 辅助方法，便于你构建“撤销”“清空聊天”或审计功能。

<Code
  lang="typescript"
  code={manageHistory}
  title="Read and edit stored items"
/>

`session.getItems()` 返回已存储的 `AgentInputItem[]`。调用 `popItem()` 可移除最后一条——适用于用户更正后重新运行智能体的场景。

---

## 自定义存储与合并行为

### 自带存储接入

你可以实现 `Session` 接口，用 Redis、DynamoDB、SQLite 或其他数据存储来承载记忆。只需五个异步方法。

<Code
  lang="typescript"
  code={customSession}
  title="Custom in-memory session implementation"
/>

自定义会话可让你在持久化前强制执行保留策略、增加加密，或为每轮对话附加元数据。

---

### 历史与新条目的合并控制

当你将 `AgentInputItem` 数组作为运行输入时，可提供 `sessionInputCallback`，以确定性方式将其与已存储历史合并。runner 会加载现有历史，在**模型调用前**调用你的回调，并将回调返回的数组作为该轮完整输入传给模型。这个钩子非常适合裁剪旧条目、去重工具结果，或仅突出你希望模型看到的上下文。

<Code
  lang="typescript"
  code={sessionInputCallback}
  title="Truncate history with sessionInputCallback"
/>

对于字符串输入，runner 会自动合并历史，因此该回调是可选的。该回调
仅在你的轮次输入本身就是条目数组时才会执行。

---

## 可恢复运行

### 审批与可恢复运行处理

人机协作流程通常会暂停运行以等待审批：

<Code
  lang="typescript"
  code={resumableRunExample}
  title="Resume a run with the same session"
/>

当你从之前的 `RunState` 恢复时，新轮次会追加到同一记忆记录中，以保持单一对话历史。Human-in-the-loop（HITL）流程仍完全兼容——审批检查点依然通过 `RunState` 往返，而会话会保持对话历史完整。

---

## 高级：历史压缩

### OpenAI Responses 历史自动压缩

`OpenAIResponsesCompactionSession` 可装饰任意 `Session`，并使用 OpenAI Responses API 将较长的已存储历史替换为等价但更短的对话条目列表。每次轮次持久化后，runner 会将最新 `responseId` 传入 `runCompaction`；当你的决策钩子返回 true 时，它会调用 `responses.compact`。根据 `compactionMode`，请求会基于最新的 Responses API 链路，或基于会话当前条目构建。默认触发条件是至少累计 10 条非用户条目；你可重写 `shouldTriggerCompaction`，基于 token 数或自定义启发式规则决定。压缩返回后，装饰器会清空底层会话并用压缩后的条目重写，因此请避免与 `OpenAIConversationsSession` 搭配使用，后者采用不同的服务器托管历史流程。

<Code
  lang="typescript"
  code={responsesCompactionSession}
  title="Decorate a session with OpenAIResponsesCompactionSession"
/>

`OpenAIResponsesCompactionSession` 构造选项：

| 选项                      | 类型                                          | 说明                                                                          |
| ------------------------- | --------------------------------------------- | ----------------------------------------------------------------------------- |
| `client`                  | `OpenAI`                                      | 用于 `responses.compact` 的 OpenAI 客户端。                                   |
| `underlyingSession`       | `Session`                                     | 用于清空/重写压缩条目的底层会话存储（不能是 `OpenAIConversationsSession`）。  |
| `model`                   | `OpenAI.ResponsesModel`                       | 用于压缩请求的模型。                                                          |
| `compactionMode`          | `'auto' \| 'previous_response_id' \| 'input'` | 控制压缩使用服务器响应链还是本地输入条目。                                    |
| `shouldTriggerCompaction` | `(context) => boolean \| Promise<boolean>`    | 基于 `responseId`、`compactionMode`、候选条目和当前会话条目的自定义触发钩子。 |

当你已经使用 Responses API 的 response ID 串联轮次时，`compactionMode: 'previous_response_id'`
会很有用。`compactionMode: 'input'` 则会基于当前
会话条目重建压缩请求；当响应链不可用，或你希望以底层会话内容作为事实来源时，这很有帮助。

`runCompaction(args)` 选项：

| 选项             | 类型                                          | 说明                                                            |
| ---------------- | --------------------------------------------- | --------------------------------------------------------------- |
| `responseId`     | `string`                                      | `previous_response_id` 模式下最新的 Responses API response id。 |
| `compactionMode` | `'auto' \| 'previous_response_id' \| 'input'` | 可选：按调用覆盖已配置模式。                                    |
| `store`          | `boolean`                                     | 指示上一次运行是否存储了服务器状态。                            |
| `force`          | `boolean`                                     | 跳过 `shouldTriggerCompaction` 并立即压缩。                     |

#### 低延迟流式传输的手动压缩

压缩会清空并重写底层会话，因此 SDK 会在流式运行解析完成前等待压缩结束。如果压缩较重，最后一个输出 token 之后 `result.completed` 可能还会等待数秒。若要实现低延迟流式传输或更快轮次切换，请关闭自动压缩，并在轮次之间（或空闲时）自行调用 `runCompaction`。

<Code
  lang="typescript"
  code={manualCompactionSession}
  title="Disable auto-compaction and compact between turns"
/>

你可以随时调用 `runCompaction({ force: true })`，在归档或交接前压缩历史。可通过 `DEBUG=openai-agents:openai:compaction` 启用调试日志来追踪压缩决策。
