---
title: 工具
description: Provide your agents with capabilities via hosted tools or custom function tools
---

import { Code } from '@astrojs/starlight/components';
import toolsFunctionExample from '../../../../../../examples/docs/tools/functionTools.ts?raw';
import toolsHostedToolsExample from '../../../../../../examples/docs/tools/hostedTools.ts?raw';
import localBuiltInToolsExample from '../../../../../../examples/docs/tools/localBuiltInTools.ts?raw';
import nonStrictSchemaTools from '../../../../../../examples/docs/tools/nonStrictSchemaTools.ts?raw';
import agentsAsToolsExample from '../../../../../../examples/docs/tools/agentsAsTools.ts?raw';
import agentsAsToolsStreamingExample from '../../../../../../examples/docs/tools/agentsAsToolsStreaming.ts?raw';
import mcpLocalServer from '../../../../../../examples/docs/tools/mcpLocalServer.ts?raw';
import codexToolExample from '../../../../../../examples/docs/tools/codexTool.ts?raw';
import codexRunContextThreadExample from '../../../../../../examples/docs/tools/codexRunContextThread.ts?raw';

工具让智能体能够**执行操作**——获取数据、调用外部 API、执行代码，甚至操作计算机。JavaScript/TypeScript SDK 支持六类：

1. **OpenAI 托管工具**——与模型一起在 OpenAI 服务器上运行。_（Web 搜索、文件搜索、Code Interpreter、图像生成）_
2. **内置执行工具**——由 SDK 提供、在模型外执行的工具。_（计算机操作和 apply_patch 在本地运行；shell 可在本地或托管容器中运行）_
3. **函数工具**——用 JSON schema 包装任意本地函数，让 LLM 可以调用。
4. **Agents as tools**——将整个智能体暴露为可调用工具。
5. **MCP 服务器**——挂载 Model context protocol 服务器（本地或远程）。
6. **实验性：Codex 工具**——将 Codex SDK 包装为函数工具，以运行具备工作区感知能力的任务。

---

## 工具类别

本指南其余部分将先介绍每类工具，再总结跨类别的工具选择与提示词指导。

### 1. 托管工具（OpenAI Responses API）

当您使用 `OpenAIResponsesModel` 时，可添加以下内置工具：

| 工具             | 类型字符串           | 用途                             |
| ---------------- | -------------------- | -------------------------------- |
| Web 搜索         | `'web_search'`       | 互联网搜索。                     |
| 文件 / 检索搜索  | `'file_search'`      | 查询托管在 OpenAI 上的向量存储。 |
| Code Interpreter | `'code_interpreter'` | 在沙箱环境中运行代码。           |
| 图像生成         | `'image_generation'` | 根据文本生成图像。               |

<Code lang="typescript" code={toolsHostedToolsExample} title="Hosted tools" />

SDK 提供了返回托管工具定义的辅助函数：

| 辅助函数                        | 说明                                                                                                                                                              |
| ------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `webSearchTool(options?)`       | 提供更适合 JS 的选项，例如 `searchContextSize`、`userLocation` 和 `filters.allowedDomains`。                                                                      |
| `fileSearchTool(ids, options?)` | 第一个参数接收一个或多个向量存储 ID，并支持 `maxNumResults`、`includeSearchResults`、`rankingOptions` 和过滤器等选项。                                            |
| `codeInterpreterTool(options?)` | 未提供 `container` 时，默认使用自动管理容器。                                                                                                                     |
| `imageGenerationTool(options?)` | 支持图像生成配置，如 `model`、`size`、`quality`、`background`、`inputFidelity`、`inputImageMask`、`moderation`、`outputCompression`、`partialImages` 和输出格式。 |

这些辅助函数会将对 JavaScript/TypeScript 友好的选项名映射到底层 OpenAI Responses API 的工具载荷。完整工具 schema 与高级选项（如 ranking options 或 semantic filters）请参考 OpenAI 官方文档。

---

### 2. 内置执行工具

这些工具内置在 SDK 中，但执行发生在模型响应之外：

- **计算机操作**——实现 `Computer` 接口并传给 `computerTool()`。它始终基于您提供的本地 `Computer` 实现运行。
- **Shell**——可提供本地 `Shell` 实现，或通过 `shellTool({ environment })` 配置托管容器环境。
- **Apply patch**——实现 `Editor` 接口并传给 `applyPatchTool()`。它始终基于您提供的本地 `Editor` 实现运行。

工具调用仍由模型发起，但实际工作由您的应用或配置的执行环境完成。

<Code
  lang="typescript"
  code={localBuiltInToolsExample}
  title="Built-in execution tools"
/>

#### 计算机工具细节

`computerTool()` 可接收以下任一形式：

- 一个具体的 `Computer` 实例。
- 一个为每次运行创建 `Computer` 的初始化函数。
- 当您需要按运行范围进行初始化与清理时，提供包含 `{ create, dispose }` 的 provider 对象。

当计算机操作应暂停并等待用户审核时，使用 `needsApproval`；当您希望对计算机操作期间触发的待处理安全检查进行确认或拒绝时，使用 `onSafetyCheck`。

#### Shell 工具细节

`shellTool()` 有两种模式：

- 本地模式：提供 `shell`，并可选 `environment: { type: 'local', skills }`，以及用于自动审批处理的 `needsApproval` 和 `onApproval`。
- 托管容器模式：提供 `environment`，其 `type` 为 `'container_auto'` 或 `'container_reference'`。

在本地模式下，`environment.skills` 允许您通过 `name`、`description` 和文件系统 `path` 挂载本地技能。

在托管容器模式下，使用以下任一方式配置 `shellTool({ environment })`：

- `type: 'container_auto'`：为本次运行创建托管容器。
- `type: 'container_reference'`：通过 `containerId` 复用现有容器。

托管 `container_auto` 环境支持：

- `networkPolicy`，包括带 `domainSecrets` 的允许列表。
- 用于挂载上传文件的 `fileIds`。
- 用于容器规格的 `memoryLimit`。
- `skills`，可使用 `skill_reference` 或内联 zip 包。

托管 shell 环境不接受 `shell`、`needsApproval` 或 `onApproval`，因为执行发生在托管容器环境中，而不是您的本地进程中。

端到端用法请参见 `examples/tools/local-shell.ts`、`examples/tools/container-shell-skill-ref.ts` 和 `examples/tools/container-shell-inline-skill.ts`。

#### Apply-patch 工具细节

`applyPatchTool()` 与 `shellTool()` 的本地审批流程一致：使用 `needsApproval` 在文件编辑前暂停；使用 `onApproval` 以便在应用层回调中自动批准或拒绝。

---

### 3. 函数工具

您可以通过 `tool()` 辅助函数把**任意**函数转换为工具。

<Code
  lang="typescript"
  code={toolsFunctionExample}
  title="Function tool with Zod parameters"
/>

#### 选项参考

| 字段                   | 必填 | 描述                                                                                                                                                                                                            |
| ---------------------- | ---- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `name`                 | 否   | 默认为函数名（例如 `get_weather`）。                                                                                                                                                                            |
| `description`          | 是   | 展示给 LLM 的清晰、可读描述。                                                                                                                                                                                   |
| `parameters`           | 是   | 可为 Zod schema 或原始 JSON schema 对象。Zod 参数会自动启用**strict**模式。                                                                                                                                     |
| `strict`               | 否   | 为 `true`（默认）时，参数校验失败会返回模型错误。设为 `false` 可进行模糊匹配。                                                                                                                                  |
| `execute`              | 是   | `(args, context, details) => string \| unknown \| Promise<...>`——您的业务逻辑。非字符串输出会序列化后提供给模型。`context` 是可选 `RunContext`；`details` 包含 `toolCall`、`resumeState` 和 `signal` 等元数据。 |
| `errorFunction`        | 否   | 自定义处理器 `(context, error) => string`，用于将内部错误转换为用户可见字符串。                                                                                                                                 |
| `timeoutMs`            | 否   | 单次调用超时时间（毫秒）。必须大于 0 且小于等于 `2147483647`。                                                                                                                                                  |
| `timeoutBehavior`      | 否   | 超时模式：`error_as_result`（默认）返回模型可见的超时消息，`raise_exception` 抛出 `ToolTimeoutError`。                                                                                                          |
| `timeoutErrorFunction` | 否   | 当 `timeoutBehavior` 为 `error_as_result` 时，自定义超时输出处理器 `(context, timeoutError) => string`。                                                                                                        |
| `needsApproval`        | 否   | 执行前要求人工审批。参见[人机协作指南](/openai-agents-js/zh/guides/human-in-the-loop)。                                                                                                                         |
| `isEnabled`            | 否   | 按运行条件决定是否暴露工具；可传布尔值或谓词。                                                                                                                                                                  |
| `inputGuardrails`      | 否   | 工具执行前运行的护栏；可拒绝或抛错。参见[护栏](/openai-agents-js/zh/guides/guardrails#tool-guardrails)。                                                                                                        |
| `outputGuardrails`     | 否   | 工具执行后运行的护栏；可拒绝或抛错。参见[护栏](/openai-agents-js/zh/guides/guardrails#tool-guardrails)。                                                                                                        |

#### 函数工具超时

使用 `timeoutMs` 为每次函数工具调用设置上界。

- `timeoutBehavior: 'error_as_result'`（默认）会向模型返回 `Tool '<name>' timed out after <timeoutMs>ms.`。
- `timeoutBehavior: 'raise_exception'` 会抛出[`ToolTimeoutError`](/openai-agents-js/openai/agents-core/classes/tooltimeouterror)，您可在[运行智能体](/openai-agents-js/zh/guides/running-agents#exceptions)的异常处理中捕获。
- `timeoutErrorFunction` 允许您在 `error_as_result` 模式下自定义超时文本。
- 超时会中止 `details.signal`，因此长时间运行的工具在监听取消时可及时停止。

如果您直接调用函数工具，可使用 [`invokeFunctionTool`](/openai-agents-js/openai/agents/functions/invokefunctiontool) 以强制与常规智能体运行一致的超时行为。

#### 非严格 JSON-schema 工具

如果您需要模型对无效或不完整输入进行*猜测*，可以在使用原始 JSON schema 时禁用 strict 模式：

<Code
  lang="typescript"
  code={nonStrictSchemaTools}
  title="Non-strict JSON schema tools"
/>

---

### 4. Agents as tools

有时您希望一个智能体*协助*另一个智能体，而不是完整交接会话。可使用 `agent.asTool()`：

<Code lang="typescript" code={agentsAsToolsExample} title="Agents as tools" />

在底层，SDK 会：

- 创建一个仅包含 `input` 参数的函数工具。
- 在工具被调用时，用该输入运行子智能体。
- 返回最后一条消息，或由 `customOutputExtractor` 提取的输出。

当您将智能体作为工具运行时，Agents SDK 会使用默认设置创建 runner，并在函数执行内运行该智能体。如果您希望提供 `runConfig` 或 `runOptions` 的任意属性，可将其传给 `asTool()` 方法以自定义 runner 行为。

您还可以通过 `asTool()` 选项为智能体工具设置 `needsApproval` 和 `isEnabled`，以集成人工干预流程和条件化工具可用性。

`agent.asTool()` 的高级结构化输入选项：

- `inputBuilder`：将结构化工具参数映射为嵌套智能体输入载荷。
- `includeInputSchema`：在嵌套运行中包含输入 JSON schema，以获得更强的 schema 感知行为。
- `resumeState`：控制恢复嵌套序列化 `RunState` 时的上下文协调策略：`'merge'`（默认）会将当前审批/上下文状态合并进序列化状态；`'replace'` 改为使用当前运行上下文；`'preferSerialized'` 则按序列化上下文原样恢复。

#### 来自智能体工具的流式事件

智能体工具可以将所有嵌套运行事件流式返回给您的应用。可根据构建工具的方式选择合适的钩子风格：

<Code
  lang="typescript"
  code={agentsAsToolsStreamingExample}
  title="Streaming agent tools"
/>

- 事件类型与 `RunStreamEvent['type']` 一致：`raw_model_stream_event`、`run_item_stream_event`、`agent_updated_stream_event`。
- `onStream` 是最简单的“全量捕获”方式，适合内联声明工具（`tools: [agent.asTool({ onStream })]`）。若不需要按事件分流，优先使用它。
- `on(eventName, handler)` 允许选择性订阅（或使用 `'*'`），适用于更细粒度处理，或希望在创建后再绑定监听器的场景。
- 只要提供了 `onStream` 或任意 `on(...)` 处理器，agent-as-tool 就会自动以流式模式运行；否则保持非流式路径。
- 处理器并行调用，因此缓慢的 `onStream` 回调不会阻塞 `on(...)` 处理器（反之亦然）。
- 当工具通过模型工具调用触发时会提供 `toolCallId`；直接 `invoke()` 调用或某些 provider 差异情况下可能缺失。

---

### 5. MCP 服务器

您可以通过 [Model Context Protocol (MCP)](https://modelcontextprotocol.io/) 服务器暴露工具，并将其挂载到智能体。
例如，您可以使用 `MCPServerStdio` 启动并连接 stdio MCP 服务器：

<Code lang="typescript" code={mcpLocalServer} title="Local MCP server" />

完整示例参见 [`filesystem-example.ts`](https://github.com/openai/openai-agents-js/tree/main/examples/mcp/filesystem-example.ts)。如果您在寻找 MCP 服务器工具集成的完整指南，请参阅 [MCP 集成指南](/openai-agents-js/zh/guides/mcp)。
在管理多个服务器（或部分失败）时，请使用 `connectMcpServers`，并参考 [MCP 集成指南](/openai-agents-js/zh/guides/mcp#managing-mcp-server-lifecycle)中的生命周期建议。

---

### 6. 实验性：Codex 工具

`@openai/agents-extensions/experimental/codex` 提供 `codexTool()`，这是一个函数工具，可将模型工具调用路由到 Codex SDK，使智能体能够自主运行工作区范围任务（shell、文件编辑、MCP 工具）。该能力为实验性，后续可能变更。

请先安装依赖：

```bash
npm install @openai/agents-extensions @openai/codex-sdk
```

快速开始：

<Code
  lang="typescript"
  code={codexToolExample}
  title="Experimental Codex tool"
/>

需要了解：

- 认证：提供 `CODEX_API_KEY`（推荐）或 `OPENAI_API_KEY`，也可传入 `codexOptions.apiKey`。
- 输入：严格 schema——`inputs` 至少包含一个 `{ type: 'text', text }` 或 `{ type: 'local_image', path }`。
- 安全：将 `sandboxMode` 与 `workingDirectory` 搭配使用；若目录不是 Git 仓库，请设置 `skipGitRepoCheck`。
- 线程：`useRunContextThreadId: true` 会在 `runContext.context` 中读取/存储最新 thread id，便于在应用状态中跨轮次复用。
- Thread ID 优先级：工具调用的 `threadId`（若您的 schema 包含）优先，其次是 run-context thread id，最后是 `codexTool({ threadId })`。
- 运行上下文键：`name: 'codex'` 时默认为 `codexThreadId`；像 `name: 'engineer'` 这类名称则为 `codexThreadId_<suffix>`（归一化后为 `codex_engineer`）。
- 可变上下文要求：启用 `useRunContextThreadId` 时，请将可变对象或 `Map` 作为 `run(..., { context })` 传入。
- 命名：工具名会归一化到 `codex` 命名空间（`engineer` 会变为 `codex_engineer`），并且同一智能体内重复的 Codex 工具名会被拒绝。
- 流式传输：`onStream` 映射 Codex 事件（推理、命令执行、MCP 工具调用、文件变更、Web 搜索），便于记录或追踪进度。
- 输出：工具结果包含 `response`、`usage` 和 `threadId`，且 Codex token 使用量会记录到 `RunContext`。
- 结构：`outputSchema` 可为描述符、JSON schema 对象或 Zod 对象。对于 JSON 对象 schema，`additionalProperties` 必须为 `false`。

运行上下文线程复用示例：

<Code
  lang="typescript"
  code={codexRunContextThreadExample}
  title="Codex run-context thread reuse"
/>

---

## 工具策略与最佳实践

### 工具使用行为

关于控制模型何时以及如何必须使用工具（`modelSettings.toolChoice`、`toolUseBehavior` 等），请参阅[智能体指南](/openai-agents-js/zh/guides/agents#forcing-tool-use)。

---

### 最佳实践

- **简短且明确的描述**——说明工具做*什么*，以及*何时使用*。
- **校验输入**——尽可能使用 Zod schema 进行严格 JSON 校验。
- **避免在错误处理器中产生副作用**——`errorFunction` 应返回有帮助的字符串，而不是抛出异常。
- **每个工具单一职责**——小而可组合的工具更有利于模型推理。

---

## 后续步骤

- 了解[强制工具使用](/openai-agents-js/zh/guides/agents#forcing-tool-use)。
- 添加[护栏](/openai-agents-js/zh/guides/guardrails)以校验工具输入或输出。
- 深入阅读 [`tool()`](/openai-agents-js/openai/agents/functions/tool) 及各类托管工具类型的 TypeDoc 参考。
