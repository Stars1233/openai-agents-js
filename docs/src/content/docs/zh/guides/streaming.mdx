---
title: 流式传输
description: Stream agent output in real time using the Runner
---

import { Code } from '@astrojs/starlight/components';
import basicStreamingExample from '../../../../../../examples/docs/streaming/basicStreaming.ts?raw';
import nodeTextStreamExample from '../../../../../../examples/docs/streaming/nodeTextStream.ts?raw';
import handleAllEventsExample from '../../../../../../examples/docs/streaming/handleAllEvents.ts?raw';
import streamedHITLExample from '../../../../../../examples/docs/streaming/streamedHITL.ts?raw';

Agents SDK 可以增量地输出来自模型和其他执行步骤的结果。流式传输可保持 UI 响应，不必等待整个最终结果再更新给用户。

## 启用流式传输

向 `Runner.run()` 传入 `{ stream: true }` 选项即可获得流式对象，而不是完整运行结果：

<Code
  lang="typescript"
  code={basicStreamingExample}
  title="Enabling streaming"
/>

启用流式传输后，返回的 `stream` 实现了 `AsyncIterable` 接口。每个产出的事件都是一个对象，描述运行期间发生的事情。该流会产出三种事件类型之一，分别描述智能体执行的不同部分。多数应用只关心模型的文本，因此流也提供了便捷方法。

### 获取文本输出

调用 `stream.toTextStream()` 可获得已发出的文本流。若 `compatibleWithNodeStreams` 为 `true`，返回值是常规的 Node.js `Readable`。我们可以直接将其管道到 `process.stdout` 或其他目标位置。

<Code
  lang="typescript"
  code={nodeTextStreamExample}
  title="Logging out the text as it arrives"
  meta={`{13-17}`}
/>

当运行及所有待处理回调完成后，`stream.completed` 这个 promise 会 resolve。若要确保不再有更多输出，请务必等待它。

### 监听所有事件

你可以使用 `for await` 循环在事件到达时逐一检查。可用信息包括底层模型事件、任何智能体切换以及 SDK 特定的运行信息：

<Code
  lang="typescript"
  code={handleAllEventsExample}
  title="Listening to all events"
/>

参见 [the streamed example](https://github.com/openai/openai-agents-js/tree/main/examples/agent-patterns/streamed.ts)，其中包含一个完整脚本，同时打印纯文本流与原始事件流。

### Responses WebSocket 传输（可选）

本页的流式 API 同样适用于 OpenAI Responses WebSocket 传输。

使用 `setOpenAIResponsesTransport('websocket')` 全局启用，或使用你自己的 `OpenAIProvider` 并设置 `useResponsesWebSocket: true`。

仅为了通过 WebSocket 进行流式传输，你不需要 `withResponsesWebSocketSession(...)` 或自定义 `OpenAIProvider`。如果可以接受在运行之间重新连接，启用该传输后，`run()` / `Runner.run(..., { stream: true })` 仍然可用。

当你需要复用连接并更明确地控制 provider 生命周期时，请使用 `withResponsesWebSocketSession(...)` 或自定义的 `OpenAIProvider` / `Runner`。

参见 [`examples/basic/stream-ws.ts`](https://github.com/openai/openai-agents-js/tree/main/examples/basic/stream-ws.ts)，内含带流式传输、工具调用、审批与 `previousResponseId` 的完整示例。

## 事件类型

该流会产出三种不同的事件类型：

### raw_model_stream_event

```ts
type RunRawModelStreamEvent = {
  type: 'raw_model_stream_event';
  data: ResponseStreamEvent;
};
```

示例：

```json
{
  "type": "raw_model_stream_event",
  "data": {
    "type": "output_text_delta",
    "delta": "Hello"
  }
}
```

### run_item_stream_event

```ts
type RunItemStreamEvent = {
  type: 'run_item_stream_event';
  name: RunItemStreamEventName;
  item: RunItem;
};
```

交接负载示例：

```json
{
  "type": "run_item_stream_event",
  "name": "handoff_occurred",
  "item": {
    "type": "handoff_call",
    "id": "h1",
    "status": "completed",
    "name": "transfer_to_refund_agent"
  }
}
```

### agent_updated_stream_event

```ts
type RunAgentUpdatedStreamEvent = {
  type: 'agent_updated_stream_event';
  agent: Agent<any, any>;
};
```

示例：

```json
{
  "type": "agent_updated_stream_event",
  "agent": {
    "name": "Refund Agent"
  }
}
```

## 流式传输中的人工干预

流式传输可与会暂停执行的交接兼容（例如某个工具需要审批时）。流对象上的 `interruption` 字段会暴露这些中断，你可以通过对每个中断调用 `state.approve()` 或 `state.reject()` 来继续执行。再次以 `{ stream: true }` 执行可恢复流式输出。

<Code
  lang="typescript"
  code={streamedHITLExample}
  title="Handling human approval while streaming"
/>

一个与用户交互的更完整示例见
[`human-in-the-loop-stream.ts`](https://github.com/openai/openai-agents-js/tree/main/examples/agent-patterns/human-in-the-loop-stream.ts)。

## 提示

- 记得在退出前等待 `stream.completed`，以确保所有输出都已刷新。
- 初始的 `{ stream: true }` 选项仅适用于提供它的那次调用。若使用 `RunState` 重新运行，必须再次指定该选项。
- 如果你的应用只关心文本结果，优先使用 `toTextStream()`，以避免逐个处理事件对象。

借助流式传输与事件系统，你可以将智能体集成到聊天界面、终端应用，或任何用户能从增量更新中受益的场景。
