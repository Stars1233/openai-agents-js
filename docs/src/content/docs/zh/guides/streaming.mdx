---
title: 流式传输
description: Stream agent output in real time using the Runner
---

import { Code } from '@astrojs/starlight/components';
import basicStreamingExample from '../../../../../../examples/docs/streaming/basicStreaming.ts?raw';
import nodeTextStreamExample from '../../../../../../examples/docs/streaming/nodeTextStream.ts?raw';
import handleAllEventsExample from '../../../../../../examples/docs/streaming/handleAllEvents.ts?raw';
import streamedHITLExample from '../../../../../../examples/docs/streaming/streamedHITL.ts?raw';
import runRawModelStreamEventExample from '../../../../../../examples/docs/streaming/runRawModelStreamEvent.ts?raw';
import runItemStreamEventExample from '../../../../../../examples/docs/streaming/runItemStreamEvent.ts?raw';
import runAgentUpdatedStreamEventExample from '../../../../../../examples/docs/streaming/runAgentUpdatedStreamEvent.ts?raw';

Agents SDK 可以按增量方式交付模型输出和其他执行步骤的结果。  
流式传输可让您的 UI 保持响应，避免在更新用户之前必须等待完整的最终结果。

## 启用流式传输

向 `Runner.run()` 传入 `{ stream: true }` 选项，即可获得流对象而不是完整结果：

<Code
  lang="typescript"
  code={basicStreamingExample}
  title="Enabling streaming"
/>

启用流式传输后，返回的 `stream` 实现了 `AsyncIterable` 接口。每个产出的事件对象都描述了本次运行中发生的内容。流会产出三种事件类型，分别描述智能体执行过程中的不同部分。  
不过，大多数应用只关心模型文本，因此该流也提供了辅助方法。

### 获取文本输出

调用 `stream.toTextStream()` 可获得一个已发出文本的流。  
当 `compatibleWithNodeStreams` 为 `true` 时，返回值是标准的 Node.js `Readable`。我们可以将其直接 pipe 到 `process.stdout` 或其他目标。

<Code
  lang="typescript"
  code={nodeTextStreamExample}
  title="Logging out the text as it arrives"
  meta={`{13-17}`}
/>

当运行及所有待处理回调完成后，`stream.completed` 这个 promise 会 resolve。若要确保没有更多输出，请始终等待它。  
这也包括在最后一个文本 token 到达后才完成的后处理工作，例如会话持久化或历史压缩钩子。

`toTextStream()` 仅发出 assistant 文本。工具调用、交接、审批及其他运行时事件可通过完整事件流获取。

### 监听所有事件

您可以使用 `for await` 循环在每个事件到达时进行检查。  
有用的信息包括底层模型事件、任何智能体切换以及 SDK 特定的运行信息：

<Code
  lang="typescript"
  code={handleAllEventsExample}
  title="Listening to all events"
/>

参见[流式传输示例](https://github.com/openai/openai-agents-js/tree/main/examples/agent-patterns/streamed.ts)，这是一个完整脚本，同时打印纯文本流和原始事件流。

### Responses WebSocket 传输（可选）

本页的流式 API 也适用于 OpenAI Responses WebSocket 传输。

可通过 `setOpenAIResponsesTransport('websocket')` 全局启用，或使用带有 `useResponsesWebSocket: true` 的自定义 `OpenAIProvider`。

若仅需通过 WebSocket 流式传输，您不需要 `withResponsesWebSocketSession(...)` 或自定义 `OpenAIProvider`。如果可接受在不同运行间重连，启用该传输后 `run()` / `Runner.run(..., { stream: true })` 仍可正常工作。

当您希望复用连接并更明确地控制 provider 生命周期时，请使用 `withResponsesWebSocketSession(...)` 或自定义 `OpenAIProvider` / `Runner`。

配合 `previousResponseId` 的续接与 HTTP 传输语义相同。区别仅在于传输方式和连接生命周期。

如果您自行构建 provider，关闭时请记得调用 `await provider.close()`。  
默认情况下，基于 Websocket 的模型包装器会被缓存以便复用，关闭 provider 会释放这些连接。`withResponsesWebSocketSession(...)` 也提供相同复用能力，但会自动将清理范围限定在单个回调内。

完整示例见 [`examples/basic/stream-ws.ts`](https://github.com/openai/openai-agents-js/tree/main/examples/basic/stream-ws.ts)，其中包含流式传输、工具调用、审批和 `previousResponseId`。

## 事件类型

该流会产出三种不同的事件类型：

### raw_model_stream_event

<Code
  lang="typescript"
  code={runRawModelStreamEventExample}
  title="RunRawModelStreamEvent"
/>

示例：

```json
{
  "type": "raw_model_stream_event",
  "data": {
    "type": "output_text_delta",
    "delta": "Hello"
  }
}
```

### run_item_stream_event

<Code
  lang="typescript"
  code={runItemStreamEventExample}
  title="RunItemStreamEvent"
/>

`name` 用于标识产出的条目类型：

| `name`                    | 含义                               |
| ------------------------- | ---------------------------------- |
| `message_output_created`  | 创建了一个消息输出条目。           |
| `handoff_requested`       | 模型请求了一次交接。               |
| `handoff_occurred`        | 运行时已完成向另一个智能体的交接。 |
| `tool_called`             | 发出了一个工具调用条目。           |
| `tool_output`             | 发出了一个工具结果条目。           |
| `reasoning_item_created`  | 发出了一个推理条目。               |
| `tool_approval_requested` | 一个工具调用因需要人工审批而暂停。 |

交接负载示例：

```json
{
  "type": "run_item_stream_event",
  "name": "handoff_occurred",
  "item": {
    "type": "handoff_call",
    "id": "h1",
    "status": "completed",
    "name": "transfer_to_refund_agent"
  }
}
```

### agent_updated_stream_event

<Code
  lang="typescript"
  code={runAgentUpdatedStreamEventExample}
  title="RunAgentUpdatedStreamEvent"
/>

示例：

```json
{
  "type": "agent_updated_stream_event",
  "agent": {
    "name": "Refund Agent"
  }
}
```

## 流式传输中的人工干预

流式传输与会暂停执行的交接兼容（例如工具需要审批时）。`stream` 对象上的 `interruptions` 字段会暴露待处理的审批，您可以对每一项调用 `state.approve()` 或 `state.reject()` 继续执行。  
流暂停后，`stream.completed` 会 resolve，且 `stream.interruptions` 包含待处理审批。再次使用 `{ stream: true }` 执行时，会恢复流式输出。

<Code
  lang="typescript"
  code={streamedHITLExample}
  title="Handling human approval while streaming"
/>

一个与用户交互的更完整示例是
[`human-in-the-loop-stream.ts`](https://github.com/openai/openai-agents-js/tree/main/examples/agent-patterns/human-in-the-loop-stream.ts)。

## 提示

- 退出前请记得等待 `stream.completed`，以确保所有输出都已刷新。
- 初始的 `{ stream: true }` 选项只对提供该选项的那次调用生效。若您使用 `RunState` 重新运行，必须再次指定该选项。
- 如果您的应用只关心文本结果，建议优先使用 `toTextStream()`，避免处理单个事件对象。

借助流式传输与事件系统，您可以将智能体集成到聊天界面、终端应用，或任何能让用户受益于增量更新的场景中。
